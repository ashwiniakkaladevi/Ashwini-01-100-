<html>
    <head>
        <title>pages</title>
        <link rel="stylesheet" href="stylee.css">
    </head>
    <body>
        <hr style="height: 2px; color: black; background-color: black;">
        <h2 class="A"><b>Chapter 1. Overview</b></h2>
        <p>This document describes IBM Tivoli NetView for z/OS Resource Object Data<br>
            Manager (RODM), which runs under the z/OS operating system. This document<br>
            describes how to: </p>
            <li><ul> Manually define your network resources to RODM so that you can manage<br>
            these resources using NetView management console.</ul></li>
            <li><ul> Automate network operations based on the status of resources stored in RODM.</ul></li>
            <li><ul> Write programs that use the services of RODM.</ul></li>
            <p>RODM is an object-oriented data cache. Objects in RODM represent resources in<br>
            your network. The data cache is located entirely in the memory of the host<br>
            processor resulting in fast access to data and high transaction rates. Many<br>
            applications can interact with a single RODM, and more than one RODM can run<br>
            on a host processor. You can use RODM for many tasks. RODM provides<br>
            application programming interfaces (APIs) that can be used by any application<br>
            running in the host processor. <br>
            The Graphic Monitor Facility host subsystem (GMFHS) is the host program that<br>
            works with RODM and the NetView program running on the host processor, and<br>
            NetView management console to manage resources.<br><br>
            GMFHS works with the SNA topology manager and NetView management console<br>
            to manage SNA resources. For more information, see the <i>IBM Tivoli NetView for<br>
            z/OS SNA Topology Manager Implementation Guide, SC27-2864.</i><br> <br>
            GMFHS also works with MultiSystem Manager and NetView management console<br>
            to manage non-SNA resources. For more information, see the <i>IBM Tivoli NetView<br>
            for z/OS User's Guide: NetView Management Console</i></p><br>
            <hr style="height: 1px; color: black; background-color: black;">
            <h3 class="A"><b>Managing SNA Resources with the NetView Program</b></h3>
            <p>Using the SNA topology manager, the NetView program provides subarea and<br>
                Advanced Peer-to-Peer Networking (APPN) network management from NetView<br>management console. You can display graphic views of resources in the network,<br>
                and you can issue commands to resources you select from the view. The views<br>
                contain both status and configuration information about your network. For more<br>
                information, see the <i>IBM Tivoli NetView for z/OS SNA Topology Manager<br>
                Implementation Guide.</i> </p><br>
            <hr style="height: 1px; color: black; background-color: black;">
            <h3 class="A"><b>Defining Non-SNA Resources to the NetView Program</b></h3>
            <p>Using the MultiSystem manager, the NetView program enables you to dynamically<br>
                discover and manage non-SNA networks from NetView management console. You<br>
                can display graphic views of resources in the network, and you can issue<br>
                commands to resources you select from the view. The views contain both status<br>
                and configuration information about your network.<br>
                You can also manually define your non-SNA resources. You need to provide<br>
                information about your network to the NetView program so that views can be<br>
                created and commands can be processed. For SNA networks, the NetView program<br>gets its information from the VTAM and NCP definitions you create. For non-SNA</p><br>
                <hr><hr>
                <p>networks, the NetView program gets its information from RODM definitions you<br>
                    create. This document describes the RODM definitions that you need to create and<br>
                    how you can create them.<br>
                    NetView management console communicates with GMFHS. Figure 1 shows that<br>
                    GMFHS runs in its own address space in the host and communicates with RODM,<br>
                    which also runs in its own address space in the host.</p><br>
                    <img src="C:\Users\Shona\Pictures\Screenshots\figure1.png"><br>
                    <h3 class="A"><b>Resource Definition Task</b></h3>
                    <p>Resources in your non-SNA network are represented by objects in the RODM data<br>
                        cache. You can create three general types of objects:</p><br>
                    <li><ul> Management objects</ul></li>
                    <li><ul>Managed objects</ul></li>
                    <li><ul>View objects</ul></li>
                        <br>
                    <p><i>Management objects</i> represent the programs that control parts of the network and<br>
                        that connect to the NetView program. IBM Tivoli Network Manager is an example<br>
                        of a management object. The programs represented by management objects send<br>
                        alerts to NetView to update the status of resources in the network. These programs<br>
                        receive commands from the NetView program for the network resources they<br>
                        control.<br><br>
                    <i>Managed objects</i> represent the network resources that you are managing. Managed<br>
                        objects contain both status and configuration information. A personal computer<br>
                        connected to a token-ring local area network (LAN) and a printer connected to an<br>
                        Ethernet LAN are examples of resources represented by managed objects. Managed<br>
                        objects must have a corresponding management object that sends status to the<br>
                        NetView program and receives commands for the resource</p><br>
                        <hr><hr>
                        <p><i>View objects</i>represent graphic views that can be displayed on NetView<br>
                            management console. Most graphic views are created automatically based on the<br>
                            configuration information contained in RODM. You might also want to define<br>
                            specific views as well. The information about which resources to display and how<br>to display them is contained in the view object.<br>
                        <i>Network configuration</i> information is represented by links between managed objects.<br>
                            For example, each managed object representing a resource on a token-ring segment<br>
                            has links to each adjacent resource on the segment. You can define both the logical<br>
                            configuration and the physical configuration of your network.<br>
                            </p><br>
                            <h3 class="A"><b>Resources Supported by GMFHS</b></h3>
                            <p>GMFHS supports resources that can send status updates to the NetView program<br>in a standard format. A service point is the program that interfaces the non-SNA<br>
                                network to the SNA network that contains the NetView program. The service point<br>
                                generates alerts that GMFHS converts to the status of objects in RODM.<br>
                                The alerts sent to the NetView program identify the resource which has changed<br>
                                status. You need to assign names to RODM objects that match the names that are<br>
                                supplied by alerts. For information about how GMFHS uses resource names from<br>alerts, see Chapter 6, “Customizing GMFHS to Process and Receive Alerts and<br>
                                Resolutions,” on page 165. It also describes how you can customize GMFHS alert<br>
                                processing to recognize additional alert types.</p><br>
                                <h3 class="A"><b>Saving RODM Data</b></h3>
                                <p>All of the data in the RODM data cache is stored in memory. If you stop RODM,<br>
                                    shut down your processor, or your system fails, all of the data in the data cache is<br>
                                    lost. The checkpoint function enables you to save a copy of the data cache to DASD.<br>
                                    When you restart RODM, you can read in the stored data from DASD. The<br>
                                    checkpoint function can be requested by a program, by the z/OS console operator,<br> or by a NetView operator, if the NetView program used by the operator is set up<br>
                                    to send commands to z/OS. Because status information stored in RODM is<br>
                                    volatile, restoring data from DASD might not be appropriate.<br>
                                    A <i>warm start</i> of RODM is when you start RODM and read in checkpoint data. The<br>
                                    data cache contains the exact data at the time of the checkpoint. After a warm<br>
                                    start, you might need to update some objects in the data cache. If the applications<br>
                                    that maintain the status of your resources keep track of updates sent to RODM, the<br>
                                    applications can resend any changes since the checkpoint.<br>
                                    A <i>cold start</i> means you start RODM without checkpoint data. The data cache<br>
                                    contains only the system-defined classes. You then need to load your data model<br>
                                    and data.<br>
                                    </p>
                                    <hr style="height: 1px; color: black; background-color: black;">
                                    <h3 class="A"><b>RODM in Network Automation</b></h3>
                                    <p>Using the SNA topology manager, you can automate the management of your<br>
                                        subarea network. For more information, see the <i>IBM Tivoli NetView for z/OS SNA<br>
                                        Topology Manager Implementation Guide.</i><br>
                                         You can also automate the management of your non-SNA network resources using<br>
                                        RODM. Because GMFHS maintains the status of the non-SNA network resources in<br>
                                        the RODM data cache, you can write automation routines using the data in<br>
                                        RODM. The following RODM concepts are important to automation.<br>
                                        </p>
                                        <hr><hr>

                                        <h3 class="A"><b>Automation Concepts</b></h3>
                                        <p>Two types of programs work with RODM, user applications and methods. A<br>
                                            RODM user application is a program that runs in a different address space than<br>
                                            RODM, and that communicates with RODM using an API. The user application<br>
                                            must run on the same z/OS host as RODM. User applications can be written in<br>
                                            any programming language. Sample control blocks for the API are supplied for use<br>
                                            with PL/I and C. Therefore, you might prefer to use one of these two languages.<br>
                                            <br>
                                            A method is a program that runs in the RODM address space and communicates<br>
                                            with RODM using another API. Methods are usually small programs that perform<br>specific tasks on data in the data cache. Running or executing a method is referred<br>
                                            to as triggering the method. Methods must be written in PL/I or C. They are<br>
                                            restricted in the types of functions they can perform. There are six types of<br>
                                            methods: </p><br>
<li><ul> RODM triggers the query method for a field when the value of the field is<br>
queried. For example, it can issue a command to a network resource to request<br>
its current status. The query subfield specifies the query method for a field.</ul></li> <br>
<li><ul> RODM triggers the change method for a field when another method or user<br>
application requests to change the value of the field. For example, the change<br>
method can issue a command to change the real status of the network resource<br>
to match the new status of the object that represents the resource in RODM. The<br>
change subfield specifies the change method for a field.</ul></li><br>
<li><ul>RODM triggers the notification method when the value of a field changes. You can<br>
define any number of notification methods for a field. It notifies user<br>
applications of changes. The notification method is particularly valuable for<br>
automation tasks. The notify subfield specifies the notification methods for a field.</ul></li><br>
<li><ul>RODM triggers a named method when another method or user application<br>
requests it. A named method is specified by a field of an object or class. Named<br>
methods can be used to perform some action for a particular object or class. For<br>
example, you can create a named method that contains the commands to<br>
activate the object with which the method is associated.</ul></li><br>
<li><ul>An object-independent method is any method that is not associated with a specific<br>
object or class. Object-independent methods can act on many objects and classes.<br>
For example, an object-independent method can query the status of all objects<br>
that represent the workstations on a specified LAN.</ul></li><br>
<li><ul>The initialization method is a special type of object-independent method. The<br>
initialization method, if specified, is automatically triggered when RODM is<br>
started.</ul></li><br>
<p>The query method, change method, notification method, and named method are<br>
                                            known as object-specific methods because they are associated with a specific object<br>
                                            or class. The NetView program supplies sample methods that you can use for<br>
                                            automation tasks.<br>
                                            A set of NetView services named the RODM automation platform makes automation<br>
                                            easier. The NetView automation table, command lists, and applications can issue<br>
                                            requests to RODM to change values of fields and trigger methods. A method that<br>
                                            is supplied with the NetView program sends commands to be issued by a NetView<br>task. And the RODM automation platform provides an enhanced API which<br>
                                            enables applications in the NetView address space to issue RODM functions with<br>
                                            less programming effort.</p><br>
                                            <hr><hr>

                                            <h3 class="A"><b>Automation Examples</b></h3>
                                            <p>A typical automation implementation can use methods, a user application, and the<br>
                                                RODM automation platform. For example, you can use a notification method to<br>
                                                notify your automation application when a resource fails. Your automation<br>
                                                application can query RODM to find the resources in the network that are related<br>
                                                to the resource that failed. By querying the status of the related resources, your<br>
                                                automation application can determine the most likely location of the problem and<br>
                                                can issue commands to correct the problem.<br>
                                                You can create methods associated with specific objects in RODM that issue<br>
                                                NetView commands using the RODM automation platform. An object-specific<br>
                                                method can contain the commands to activate the resource that the method is<br>
                                                associated with. When triggered by your automation application, the object-specific<br>
                                                method sends the commands to the EKGSPPI method that is supplied with the<br>
                                                NetView program, the commands are passed to the NetView program and issued<br>
                                                by an autotask. This enables the same application to activate different types of<br>
                                                resources without knowing the commands specific to each resource.</p><br>

                <h3 class="A"><b>For More Information</b></h3>
                                            <p>This document contains two chapters specifically about automation. Read<br>
                                                    Chapter 7, “Writing Automation Code,” on page 179 for more information about<br>
                                                    automation with the GMFHS data model. Read Chapter 8, “Using the RODM<br>
                                                    Automation Platform,” on page 187 for more information about the RODM<br>
                                                    automation platform services.</p><br>
                                                    <hr style="height: 1px; color: black; background-color: black;">
                 <h3 class="A"><b>RODM Programming Tasks</b></h3>
                 <p>While this overview has focused on using RODM to support NetView<br>
                    management console and network automation, RODM can support other types of<br>
                    network and system management programs. This section describes RODM<br>
                    programming tasks in general.<br>
                    RODM can be used for any task that requires a high-speed data cache manager.<br> RODM provides an application programming interface for user application<br>
                    programs, and another application programming interface for methods. It also<br>
                    provides a load function to simplify loading data into the data cache and<br>
                    maintaining the data.<br>
                    User applications and methods have very similar interfaces to RODM. Many of the<br>
                    functions that RODM provides can be used by both types of programs. Both user<br>
                    applications and methods send function requests to RODM. RODM replies with a<br>
                    return code and reason code to indicate if the request was successful. Some<br>
                    function requests cause RODM to return data as well. A single function request<br>
                    made to RODM and the response from RODM make up a transaction.</p><br>
                    <h3 class="A"><b>RODM Transactions</b></h3>
                    <p>Many transactions request RODM to take some action on a particular class, object,<br>
                        field, or subfield in the data cache. For example, a user application sends a request<br>
                        to RODM to change the value of a field that represents the status of a network<br>
                        resource. The particular class, object, field, or subfield that the transaction specifies<br>
                        is the target of the transaction. In general, a transaction has a single target.<br>
                        Each transaction is made using a call to RODM that passes the required<br>
                        </p>
                        <hr><hr>

                        <li><ul>Access block</ul></li>
                        <li><ul>Transaction information block</ul></li>
                        <li><ul> Function block</ul></li>
                        <li><ul>Response block</ul></li>
                        <li><ul> Entity access information block</ul></li>
                        <li><ul> Field access information block</ul></li>
                            <br>
                        <p>Specific transactions use different blocks as needed<br>.
                            The <i>access block</i> identifies the user application to RODM. Methods run within<br>
                            RODM, so they never use an access block. The RODM automation platform<br>
                            services CNMQAPI and DSINOR take care of the access block for applications<br>
                            running in the NetView address space.<br>
                            The <i>transaction information block</i> is used to track each transaction with RODM.<br>
                            RODM places the return code and reason code for the transaction in this control<br>
                            block. All transactions use this block.<br>
                            The <i>function block</i> specifies the RODM function to be run. It contains the particular<br>
                            parameters that RODM needs to run the function. All transactions use this block.<br>
                            The <i>response block</i> contains any data requested from RODM. Functions that request<br>
                            data, such as query functions, use a response block.<br>
                            The <i>entity access information block</i> identifies the specific class and object that is the<br>
                            target of a transaction. This block is used when a class, object, field, or subfield is<br>
                            the target of a transaction.<br>
                            The <i>field access information block</i> identifies the specific field that is the target of a<br>
                            transaction. This block is used when a field or subfield is the target of a<br>
                            transaction.<br>
                            </p>
                            <h3 class="A"><b>RODM Functions</b></h3>
                            <p>RODM provides functions for user applications and methods. Some functions are<br>
                                available only to user applications, and some are available only to methods. Many<br>
                                functions are available to both. Each function requires a particular authorization<br>
                                level, so you can limit the functions available to particular applications.<br>
                                RODM provides functions to connect to and disconnect from RODM. It provides<br>
                                functions to checkpoint RODM and stop RODM.<br>
                                RODM provides a set of functions to change the structure of the elements in the<br>
                                data cache. There are functions to create and delete classes, objects, fields, and<br>
                                subfields. Link and unlink functions enable you to define relationships among<br>
                                objects.<br>
                                RODM provides a set of functions to change the values of the fields and subfields<br>
                                of classes and objects. Changing the value of a field triggers its change method if<br>
                                one has been defined. Changing the value of a subfield does not trigger the change<br>
                                method.<br>
                                RODM provides query functions to get information about the classes and objects in<br>
                                the data cache. Programs can query the value of any field or subfield. Querying<br><br>
                                the value of a field triggers its query method if one has been defined. Querying the<br>
                                value of a subfield does not trigger the query method. Programs can also query the</p><br>
                                <hr><hr>

                                <p>structure of the elements in the data cache. RODM also provides the ability to<br>
                                    locate objects in RODM based on the value of a character field.<br>
                                    RODM provides functions to support the notification process. Programs can add<br>
                                    and delete notification subscriptions. User applications can get information from<br>the notification queue. Notification methods support the RODM notification<br>
                                    process.<br>
                                    Other functions enable you to write diagnostic information to the RODM log and<br>
                                    trigger methods. You can issue a list of functions in a single call to RODM. You can<br>
                                    also issue asynchronous requests to RODM.<br>
                                    Each function is described in detail in Chapter 14, “Application Programming<br>
                                    Reference,” on page 371. There are sample function blocks and programming<br>
                                    examples for each function RODM provides.<br>
                                    </p>
                                    <h3 class="A"><b>Programming Languages</b></h3>
                                    <p>User applications access RODM using the RODM user application programming<br>
                                        interface. User applications can be written in any programming language<br>
                                        supported by your z/OS environment. However, RODM samples and examples are<br>
                                        provided only in PL/I and C.<br>
                                        Methods access RODM using the RODM method application programming<br>
                                        interface. RODM methods can be written only in PL/I or C. Many methods that<br>
                                        are supplied with the NetView program are supplied in source format. You can use<br>
                                        these methods as models to write your own RODM methods.</p><br>

                                        <h3 class="A"><b>RODM Notification Process</b></h3>
                                        <p>The <i>RODM notification process</i> enables user applications to receive asynchronous<br>
                                            notification of events. User applications subscribe to fields in the data cache. When<br>
                                            the value of the field changes, the notification method associated with the field is<br>
                                            triggered. The notification method writes information about the change to a<br>
                                            <i>notification queue</i> and RODM posts the <i>event control block (ECB)</i> for the user<br>
                                            application.<br>
                                            The user application waits until its ECB is posted by RODM. The user application<br>
                                            calls the EKGWAIT module to wait until the ECB is posted. The user application<br>
                                            gets the information from the notification queue and takes the appropriate actions.<br>
                                            When it finishes processing an event, the user application waits to be notified of<br>
                                            the next event.<br>
                                            </p>
                                            <h3 class="A"><b>RODM Load Function</b></h3>
                                            <p>The RODM load function provides an easy way to load the class structure and<br>
                                                objects into the RODM data cache. See the <i>IBM Tivoli NetView for z/OS Data Model<br>
                                                Reference</i> for more information about data models, class structures, fields, and<br>
                                                objects.<br>
                                                You create input statements for each class and object which are processed by the<br>
                                                load function. You can use the load function to load the initial structure and objects<br>
                                                into the data cache, and you can also use it to update and maintain the data cache<br>
                                                at any time.<br>
                                                The RODM load function accepts two types of input statements:</p><br>
                                                <hr><hr>
                                                <li><ul> High-level RODM load function statements enable you to create and delete classes<br>
                                                    and objects. Each create statement defines one class or object and all of its fields.<br>
                                                    A single high-level RODM load function statement can do the work of many<br>
                                                    RODM transactions.</ul></li> <br>
                                                    <li><ul>RODM load function primitive statements enable you to make changes to the<br>
                                                    RODM data cache that are not possible with the high-level RODM load function<br>
                                                    statements. For example, you can trigger an object-independent method or<br>
                                                    change the value of a subfield in the data cache using RODM load function<br>
                                                    primitive statements.</ul></li><br>
                <hr style="height: 1px; color: black; background-color: black;">
                <h3 class="A"><b>Additional RODM Documentation</b></h3>

                <p>This document contains information about defining a network to the GMFHS data<br>
                    model, loading the data model into the RODM data cache, and writing application<br>
                    programs and methods that use RODM. Other documents in the NetView library<br>
                    contain information about RODM that can be of use to you when you are<br>
                    performing the tasks that are outlined in this document:<br>
                    IBM Tivoli NetView for z/OS Installation: Configuring Graphical Components<br>
                    Describes procedures for installing the NetView program and for<br>
                    customizing your system and tailoring your network for your needs,<br>
                    including the following information:</p>
                    <li><ul> Defining RODM as an MVS Subsystem</ul></li>
                    <li><ul> Setting up Security</ul></li>
                    <li><ul> Defining the RODM Log</ul></li>
                    <li><ul> Updating the RODM Start Procedure</ul></li>
                    <li><ul> Defining Global Variables for RODM</ul></li>
                    <li><ul> Defining RODM Using the EKGCUST Member</ul></li>
                    <li><ul> Defining Initialization Values for RODM DSIQTSK Task</ul></li>
                    
        <p><i>IBM Tivoli NetView for z/OS Administration Reference</i><br>
            &nbsp;&nbsp;TContains the following information: </p><br>
    <li><ul> The statements that are used to define RODM and the RODM<br>
automation task</ul></li>
<li><ul>Customizing RODM using the EKGCUST member</ul></li>
    <p>
    <i>IBM Tivoli NetView for z/OS Security Reference</i><br>
    &nbsp;&nbsp;TThis document contains information for defining RODM security.<br>
<i>IBM Tivoli NetView for z/OS Automation Guide</i><br>
&nbsp;&nbsp;TDescribes how to use RODM as part of NetView automation.<br>
<i>IBM Tivoli NetView for z/OS Troubleshooting Guide</i><br>
&nbsp;&nbsp;Contains information about diagnostics and troubleshooting, including the<br>
following information:<br>
    </p>
    <li><ul>Debugging methods</ul></li>
    <li><ul> The RODM log</ul></li>
    <li><ul> The RODM dump utility</ul></li>
    <li><ul> The RODM load utility error listing</ul></li>
    <li><ul> Using RODM API statistics to improve RODM performance</ul></li>
    <p><i>IBM Tivoli NetView for z/OS Messages and Codes Volume 2 (DUI-IHS)</i><br>
        &nbsp;&nbsp;TDescribes the messages that are returned by RODM. RODM messages are<br>
        prefixed with EKG.<br>
        </p>
<hr><hr>

<p><i>IBM Tivoli NetView for z/OS SNA Topology Manager Implementation Guide</i><br>
    &nbsp;&nbsp;TDescribes how to use the SNA topology manager.<br>
<i>IBM Tivoli NetView for z/OS Data Model Reference</i><br>
    Describes the GMFHS, SNA topology manager, and MultiSystem manager<br>
    data models.<br>
<i>IBM Tivoli NetView for z/OS Tuning Guide</i><br>
    &nbsp;&nbsp;TProvides information for tuning RODM and GMFHS.<br>
<i>IBM Tivoli NetView for z/OS User's Guide: NetView</i><br>
    &nbsp;&nbsp;Provides information for operators and system programmers on how to<br>
    use the NetView program, including RODM and GMFHS.</p><br>
    <hr style="height: 1px; color: black; background-color: black;">
    <h3 class="A"><b>Tools for RODM</b></h3>
    <p>The NetView program provides the following tools for use with RODM: </p><br>
    <li><ul>RODMView</ul></li>
            <li><ul> RODM unload function</ul></li>
            <li><ul> FLCARODM (RODM Access Facility)</ul></li>
            <li><ul> RODM Collection Manager</ul></li>
            <li><ul> BLDVIEWS</ul></li>
            <li><ul> DELVIEWS</ul></li>
    <p>For more information about these tools, see Appendix A, “RODM Tools,” on page<br>
        513.</p><br>
        <hr style="height: 1px; color: black; background-color: black;">
        <h3 class="A"><b>RODM Samples and Macros</b></h3>
        <p>The NetView program provides sample code that you can use to set up your own<br>
            network in RODM and to learn how to write application programs and methods. It<br>
            also supplies macros for you to include in the application programs and methods<br>
            that you write. The sample code and macros, which are shipped with the NetView<br><br>product, can be found in the following libraries:</p>
    <p><h4><b>NETVIEW.V6R2M1.CNMSAMP</b></h4>
        &nbsp;&nbsp;TThis library contains sample code that you can use to define and load your<br>
        &nbsp;&nbsp;Tnetwork into RODM. Additionally, this library contains sample code that<br>
        &nbsp;&nbsp;Tyou can use to learn how to connect to RODM and how to write<br>
        &nbsp;&nbsp;Tapplication programs and methods that use GMFHS automation. The<br>
        &nbsp;&nbsp;Tnames of the function samples have prefixes EKG5 and EKG6.<br>
        <h4><b>NETVIEW.V6R2M1.SCNMMAC1</b></h4>
        &nbsp;&nbsp;This library contains the macros that you include in your application<br><br>
        &nbsp;&nbsp;Tprograms and methods. The names of these macros have prefixes EKG1,<br>
        &nbsp;&nbsp;TEKG2, EKG3, and EKG4. For more information about these macros, see<br>
        &nbsp;&nbsp;TChapter 14, “Application Programming Reference,” on page 371.<br>
        &nbsp;&nbsp;TSome of these macros and parts of the sample code are described in this document.<br>
        &nbsp;&nbsp;TThe names of the specific macros or functions are listed in the sections in which<br>
        &nbsp;&nbsp;Tthey are described.</p><br>

        <hr><hr>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<hr><hr>

<hr style="height: 2px; color: black; background-color: black;"><br>
<h3 class="A"><b>Part 2. Defining Resources to the NetView Program</b></h3>     
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<hr><hr>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<hr><hr>

<hr style="height: 2px; color: black; background-color: black;"><br>
<h3 class="A"><b>Chapter 2. Defining Your Network to GMFHS</b></h3>  
<p>
    You can manually define your network configuration to the NetView program<br>
based on the GMFHS data model. This chapter first describes a sample network,<br>
and then shows the steps for manually defining a network.<br>
Notes:<br>
1. You can use the SNA topology manager to define your SNA network to<br>
RODM. Refer to the IBM Tivoli NetView for z/OS SNA Topology Manager<br>
Implementation Guide for more information.<br>
2. You can use MultiSystem Manager to define your non-SNA network to RODM.<br>
To help you manually define your network to RODM, a sample object load file,<br>
DUIFSNET, is provided with the NetView program. The sample file contains the<br>
RODM load function statements that define the sample network to RODM.<br>
You manually define your network using RODM load function statements. You can<br>
generate these statements in any of the following ways:<br>
<li><ul>If you have configuration information stored in a repository, write a conversion<br>
program to convert the information to the RODM load file format presented in<br>
Chapter 10, “Using the RODM Load Function,” on page 239.</ul></li><br>
<li><ul>Create the configuration definitions with a text editor.</ul></li> <br><br>
 You can also define your network without using the RODM load function. If you<br>
have your network configuration information stored in a database, you can write a<br>
RODM user application that places the configuration information directly into<br>
RODM. Your user application puts the data into RODM by issuing calls to the<br>
RODM user API. See Chapter 11, “Writing Applications that Use RODM,” on page<br>
305 for information about writing RODM user applications.<br>
</p>
<hr style="height: 1px; color: black; background-color: black;"><br>
<h3 class="A"><b>Manual Network Definition Overview</b></h3> 
<p>To manually define your network configuration to RODM, perform the following<br>
    tasks in the order listed:<br>
    1. Analyze your configuration and identify the network elements that you need to<br>
    define to RODM.<br>
    2. Define the management objects in your network. Management objects are: 
<li><ul> SNA domains</ul></li>
<li><ul> Network management gateways</ul></li>
<li><ul> Non-SNA domains</ul></li>
    3. Define the managed objects in your networks. Managed objects are:<br><br>
    <li><ul> Real non-SNA objects for which you are to receive status, alerts, or both<br>
    through a service point</ul></li>
    <li><ul>SNA objects that appear in views with non-SNA objects</ul></li>
    <li><ul>Aggregate objects</ul></li>
    4. Define connectivity relationships for the resources in your network. Examples<br>
    of connectivity relationships include logical and physical connectivity,<br> parent-child, composed-of-logical, composed-of-physical, and is-part-of.<br>
    </p>

    <hr><hr>

    5. Define the types of views of your configuration that you want the operator to<br>
see.<br>
<hr style="height: 1px; color: black; background-color: black;"><br>
<h3 class="A"><b>Sample Network</b></h3> 
<p>This chapter uses a sample network (as shown in Figure 2) to describe how to<br>
    define your network to RODM. This network contains both SNA and non-SNA<br>
    components.<br>
    </p>
    <img src="C:\Users\Shona\Pictures\Screenshots\Figure2.png"><br>
    <br>
<h3 class="A"><b>SNA Components of the Sample Network</b></h3> 
<p>The sample network consists of two network domains: network NETA and<br>
    network NETB.</p><br>

<hr><hr>
<p>Network NETA consists of the following components: </p><br>
<li><ul>Host processor A01MPU, running a NetView program and VTAM</ul></li>
 <li><ul>NCP A04A54C, which connects the host processor to a token-ring LAN</ul></li>
<li><ul>NMG A0488P21, which manages the token-ring LAN network (TRLAN network)</ul></li>
<li><ul>Token-ring LAN network</ul></li>
    Network NETB consists of the following components: <br>
    <li><ul>Host B01MPU, running a NetView program and VTAM</ul></li>
        <li><ul>NCP B30A54C, which connects the host to a token-ring</ul></li>
            <li><ul>NMG B3088P1, which manages the Ethernet network</ul></li>
                <li><ul>NMG B3088P2, which manages the sysplex network</ul></li>
                    <li><ul>Ethernet network</ul></li>
                        <li><ul>Sysplex network</ul></li>
<p>
    The two host systems are connected by two logical gateway connectors, V01LG01<br>
    and V63LG01, through NCP/Token-Ring interconnection (NTRI). These logical<br>
    gateway connectors between the two NCPs are associated with the two token-ring<br>
    LANs with a bridge between them. The SNA links connecting the service points to<br>
    their NCPs also use token rings for their underlying physical connectivity.<br>
     The hosts, NCPs, service points, gateway connectors, and link connectors in the<br>
    sample network are SNA resources managed by the NetView and VTAM<br>
    programs. The focal point NetView program, GMFHS, and RODM run in host<br>
    A01MPU. The NetView management console monitors these SNA resources and<br>
    generates views for them.<br>
    </p>
    <h3 class="A"><b>Non-SNA Components of the Sample Network</b></h3> 
    <p>NetView management console does not recognize the non-SNA components of the<br>
        sample network. For a NetView management console to manage these non-SNA<br>
        components, they must be defined to RODM using the GMFHS data model.<br>
        <h4><b>Service Points</b></h4><br>
        The following four service points, defined as network management gateways, are<br>
        in the sample network:<br> 
        <li><ul>NMG B3088P1 runs the SYNOPTAP transaction program, which manages the<br>
        Ethernet network.</ul></li>
        <li><ul>NMG B3088P2 runs the NetView program, which manages the remote sysplex.</ul></li>
        <li><ul>NMG A0488P21 runs in the token-ring LAN and manages the TRLAN network.</ul></li>
        <li><ul>NMG A0488P31 manages the ITNM network.</ul></li>
   
        <h4><b>Sysplex Network</b></h4> 
        Figure 3 on page 18 shows more detail about the sysplex network shown in the<br>
        sample network. The sysplex network consists of:<br>
        <li><ul>PLEX1 reports to enterprise master NetView program in NMG B3088P2.</ul></li>
        <li><ul>The RALXT1 and RALXT2 z/OS systems connect to PLEX1.</ul></li></p>
         <hr><hr>

         <img src="C:\Users\Shona\Pictures\Screenshots\Figure3.png">
         
            <h4><b>Ethernet Network</b></h4> 
            <p>Figure 4 shows more detail of the Ethernet network in the sample network. An<br>
adapter on service point B3088P1 connects the service point to synoptic<br>
concentrator CNTR3000. The concentrator is connected to the host systems through<br>
three connectors: <br>
<li><ul> Connector NSL_ENET, which is associated with the Windows system and the<br>
AIX® system</ul></li><br>
<li><ul> Connector NSL_B202, which is associated with host AS400.</ul></li>
<li><ul> Connector OEMLAB, which is associated with two non-SNA (Solaris and Linux)<br>
hosts</ul></li>

<img src="C:\Users\Shona\Pictures\Screenshots\Figure4.png"><br>
<h4><b>Token-Ring Local Area Network</b></h4> 
    <p>Figure 5 on page 19 shows token-ring network TRLAN. It consists of the following<br>
    resources:
    <li><ul>Adapter TRADPTR, which connects NCP A04A54C to the token ring</ul></li>
    <li><ul> Resource A04N1088, which is the SNA line representing the token-ring interface<br>
    coupler (TIC)</ul></li>
    <li><ul> Resource A04P1088, which is defined for the SNA physical unit (PU) for the TIC</ul></li></p>

<hr><hr>

<p>
    <li><ul>Resources A0488P21 through A0488P25, which are token-ring adapters for<br>
    programmable workstations and are associated with the appropriate adapter<br>
    addresses in the LAN Manager</ul></li>
    <li><ul>BRIDGE01, which is a bridge on the LAN that connects to another token ring in<br>
    NETB</ul></li>
    The sample network defines SNA PU 2 resources representing the programmable<br>
    workstations to SNA, and has named the SNA PUs A0488P21 through A0488P25,<br>
    associating the SNA PUs to the adapter resident in each workstation that supports<br>
    a PU. The sample network uses the DisplayResourceName field to specify the<br>
    name that is displayed for each resource in the token-ring network. For example,<br>
    the object LANMGR.10005AC35CA0 has its DisplayResourceName field set to<br>
    A0488P21. This enables you to display names for resources that are meaningful to<br>
    your operators.<br>
    </p>
        <img src="C:\Users\Shona\Pictures\Screenshots\Figure5.png"><br>
        <h4><b>ITNM Network  </b></h4>
            <p>Figure 6 on page 20 shows more detail for the ITNM network in the sample<br>
            network. The ITNM network is the IP network that is managed by IBM Tivoli<br>
            Network Manager. The ITNM network consists of the following resources:<br>
            <li><ul>IBM Tivoli Network Manager</ul></li>
            <li><ul> Workstations T46A, T47A, T47B, T48A, and T48B</ul></li>
            IBM Tivoli Network Manager is configured on the A0488P31 system. Workstations<br>
            T46A, T47A, T47B, T48A, and T48B are connected to the TCP/IP network in which<br>
            IBM Tivoli Network Manager resides. IBM Tivoli Network Manager converts<br>
            selected traps related to these resources into alerts, which are then sent to the focal<br>
            point host A01MPU.</p><br>

            <hr><hr>

            <img src="C:\Users\Shona\Pictures\Screenshots\Figure6.png"><br>
            <hr style="height: 1px; color: black; background-color: black;"><br>
            <h3><b>Identifying Network Elements to Define</b></h3>

            <p>To properly define your network to RODM, assess your network components and<br>
                their configuration, and then identify the network elements. The elements to<br>
                identify are:<br>
            
                <li><ul>Management objects</ul></li>
                <li><ul>Managed objects</ul></li>
                <li><ul>Connectivity relationships</ul></li>
                <li><ul>Desired views</ul></li><br>
                <h4><b>SNA Domains</b></h4>
                    An SNA domain represents one NetView program. You need to define to RODM<br>
                    one SNA domain for each NetView program that can originate alerts for SNA<br>
                    resources, if these SNA resources are defined as shadow objects to RODM.<br>
                    You also need to define an SNA domain for each NetView program that has a<br>
                    non-SNA domain reporting to it, even if it has no SNA shadow objects defined on<br>
                    it. This ensures command support for the non-SNA objects and enables GMFHS to<br>
                    determine if the status of resources in the non-SNA domain is known. For<br>
                    information about shadow objects, see “Identifying Managed Objects” on page 21.<br>
                    In the sample network, one SNA domain is defined for each of the NetView<br>
                    programs that reside in hosts B01MPU and A01MPU.<br>
                    <h4><b>Network Management Gateways</b></h4>
                    A network management gateway (NMG) is a gateway between the NetView<br>
                    program and the network management function of one or more non-SNA<br>
                    networks. The AIX and IBM Tivoli Network Manager service points are examples</p><br>

                    <hr><hr>
                    of NMGs. An NMG can also be a user-written service point that uses service point<br>
command service (SPCS) support or sends alerts by some other means.<br>
Two other NetView facilities that support network management gateways are the<br>
program-to-program interface (PPI) and operator station tasks (OSTs). The<br>
program-to-program interface provides a path for the exchange of network<br>
management information and commands for applications that manage non-SNA<br>
resources and run in the focal point host in address spaces other than the NetView<br>address space. OSTs run command procedures and command processors that<br>
accept network management commands for, and provide status of, non-SNA<br>
resources.<br>
In the sample network, four service points are defined as network management<br>
gateways: <br>
<li><ul>B3088P2</ul></li>
    <li><ul>B3088P1</ul></li>
        <li><ul>A0488P31</ul></li>
            <li><ul>A0488P21</ul></li>
<h4><b>Non-SNA Domains</b></h4>
<p>You must define a non-SNA domain for each non-SNA network being monitored.<br>
A non-SNA domain is uniquely identified by any combination of service point,<br>
transaction program, and element management system.<br>
Depending on the transaction program used, the transaction program and element<br>
management system might or might not identify themselves in alerts coming to the<br>
NetView program for non-SNA resources. A Non_SNA_Domain_Class object needs<br>
to be defined for each combination of service point, transaction program, and<br>
element management system that is identified in alerts flowing to the NetView<br>
program.<br>
In the sample network, a non-SNA domain is defined for each of the following<br>
networks:<br>
<li><ul>The Ethernet network, which has a service point named B3088P1</ul></li>
<li><ul>The sysplex network, which is connected by NMG B3088P2</ul></li>
<li><ul>The TRLAN network, which has a service point named A0488P21</ul></li>
<li><ul>The ITNM network, which has a service point named A0488P31</ul></li>
<br><br>
</p>
<h3 class="A"><b>Identifying Managed Objects</b></h3>
<p>Managed objects represent the network resources that you manage. These objects<br>
    contain status and configuration information about the network resources that they<br>
    represent. Managed objects require management objects to send status to the<br>
    NetView program and to receive commands for the resource. You identify one<br>
    managed object for each network resource that you want to manage using RODM.<br>
    Four types of managed objects can be defined to RODM:<br>
    <li><ul> SNA topology manager class objects. The SNA topology manager objects are not<br>
    included in the sample network DUIFSNET. For more information, refer to<br>
    theIBM Tivoli NetView for z/OS SNA Topology Manager Implementation Guide.</ul></li><br>
    <li><ul> GMFHS_Shadow_Objects_Class objects</ul></li>
        <li><ul> GMFHS_Managed_Real_Objects_Class objects</ul></li>
            <li><ul> GMFHS_Aggregate_Objects_Class objects</ul></li>
<br><br>
    </p>
    <hr><hr>

    <h4><b>GMFHS_Shadow_Objects_Class Objects</b></h4>
    <p>The SNA topology manager creates SNA objects for resources that it manages. If<br>
        you have other SNA resources that are not managed by SNA topology manager,<br> you can create GMFHS_Shadow_Objects_Class objects to represent them.<br>
        GMFHS_Shadow_Objects_Class objects represent SNA resources that you want to<br>
        relate to non-SNA resources. The status of shadow objects is not kept in RODM,<br>
        but is maintained by the NetView management console SNA support. When a<br>
        view containing shadow objects is displayed at the NetView management console<br>
        workstation, NetView management console fills in and maintains each object's<br>
        status.<br>
        <b>Note:</b> The NetView management console does not maintain shadow object status.<br>
        Shadow objects are displayed on the NetView management console, but the status<br>
        is always unknown.<br>
        If you want to relate SNA resources to non-SNA resources such as those in the four<br>
        non-SNA networks in the sample network, you need to define the SNA resources<br>
        as objects on the GMFHS_Shadow_Objects_Class. These<br>
        GMFHS_Shadow_Objects_Class objects are SNA resources, such as PUs, logical<br>
        units (LUs), and link connections, that are defined in RODM so that they can be<br>
        related to associated non-SNA resources.<br>
        In the sample network, logical link connectors V01LG01 and V63LG01 have been<br>
        defined and are related to the physical path that connects the two NCPs and the<br>
        two token-ring LANs. If either of the logical link connectors is displayed with a<br>
        status of unsatisfactory, the operator can select the connector and request more<br>
        detailed information about the resource. GMFHS then locates the<br>
        GMFHS_Shadow_Objects_Class object for the connector in RODM, follows the<br>
        configuration relationships to determine what resources made up the connector,<br>
         and dynamically constructs and displays a view consisting of more detailed<br>
        information.<br>
        <h4><b>GMFHS_Managed_Real_Objects_Class Objects</b></h4>
        GMFHS_Managed_Real_Objects_Class objects represent non-SNA resources that<br>
        are managed by a NetView management console. The status of each of these<br>
        resources is determined by alerts and command responses sent through the<br>
        network and is stored in RODM. Examples of these resources include multiplexers,<br>
        modems, software applications, and T1 element managers. You must define a<br>
        GMFHS_Managed_Real_Objects_Class object to GMFHS for each resource that you<br>
        manage. If you have added child classes to the<br>
        GMFHS_Managed_Real_Objects_Class, create objects of the child classes instead.<br>
        For more information, refer to the IBM Tivoli NetView for z/OS Data Model Reference.<br>
         In the sample network, a GMFHS_Managed_Real_Objects_Class object is defined<br>
        for each resource of interest in the four non-SNA networks. For example, in the<br>
        sysplex network shown in Figure 3 on page 18, a<br>
        GMFHS_Managed_Real_Objects_Class object is defined for the following resources:<br>
        <li><ul>A sysplex named PLEX1</ul></li>
        <li><ul>z/OS systems RALXT1 and RALXT2</ul></li>
        <h4><b>GMFHS_Aggregate_Objects_Class Objects</b></h4>
        GMFHS_Aggregate_Objects_Class objects represent a group of objects. This group<br>
        of objects can consist of any number and combination of real objects and aggregate<br>
        objects. Examples of aggregate objects are data centers, complex circuits composed<br>
        of multiple components, and arbitrary groups of resources.<br>
        </p><br>
<hr><hr>

<p>You can define an aggregate object to GMFHS and relate it to underlying<br>
    GMFHS_Managed_Real_Objects_Class objects. The status of the aggregate object is<br>
    determined by the status of the real objects that the aggregate object represents. If<br>
    you have added child classes to the GMFHS_Aggregate_Objects_Class, you need to<br>
    create objects of the child classes instead.<br><br>
    You can also define an aggregate object that is composed of other aggregate<br>
    objects. The status of this higher-level aggregate object is determined by the status<br>
    of the real objects that contribute to the status of the lower-level aggregate objects.<br>
    The status of the lower-level aggregate objects does not contribute to the status of<br>
    the higher-level aggregate object; only real objects contribute to the status of<br>
    aggregate objects.<br><br>
    Because GMFHS_Shadow_Objects_Class objects do not have status fields, the real<br>
    resources that they represent do not contribute to the status of an aggregate object.<br>
    GMFHS supports up to nine levels of aggregation. A level of aggregation is one<br>
    aggregate object composed of one or more real or aggregate objects. If a real object<br>
    is defined as a child of an aggregate parent object and that aggregate parent object<br>
    is defined as a child of another parent aggregate object, two levels of aggregation<br>
    have been defined.<br><br>
    Aggregate objects must be defined in a strict hierarchy. An aggregate object cannot<br>
    be defined as a child aggregate object of an aggregate object that is below it in the<br>
    aggregation hierarchy. For more information about using aggregation, see “Aggregation Concepts” on<br>
    page 128.<br><br>
    In the sample network, an aggregate object has been defined for each of the<br>
    non-SNA networks: Ethernet, Sysplex, ITNM, and TRLAN. Each of these aggregate<br>
    objects represents all of the real resources in the respective network. The status of<br>
    each of these aggregate objects reflects the collective status of the underlying real<br>
    resources.<br><br>
    Two other aggregate objects are also defined:<br>
    <li><ul> Aggregate object WESTCTR is composed of the ETHERNET and SYSPLEX<br>
    aggregate objects. The status of WESTCTR is determined by the status of the real<br>
    resources in the Ethernet and sysplex networks.</ul></li><br>
    <li><ul> Aggregate object EASTCTR is composed of aggregate objects ITNM and TRLAN.<br>
    The status of EASTCTR is determined by the status of the real resources in the<br>
    ITNM and TRLAN networks.</ul></li><br>
    These aggregate objects appear in the high-level view described in “Identifying<br>
    Views” on page 26.</p><br>

    <h3  class="A"><b>Identifying Connectivity Relationships</b></h3>
    <p>Connectivity relationships are ways in which resources defined in RODM can be<br>
        connected to each other. These relationships can be physical, logical, or peer. The<br>
        GMFHS data model supports the following relationships:<br>
        <li><ul>ComposedOfLogical and IsPartOf</ul></li>
        <li><ul>ComposedOfPhysical and IsPartOf</ul></li>
        <li><ul>AggregationParent and AggregationChild</ul></li>
        <li><ul>ParentAccess and ChildAccess</ul></li></p><br>

    <hr><hr>
    <li><ul>PhysicalConnPP</ul></li>
        <li><ul>LogicalConnPP</ul></li>
            <li><ul>PhysicalConnUpstream and PhysicalConnDownstream</ul></li>
                <li><ul>LogicalConnUpstream and LogicalConnDownstream</ul></li>
                    <li><ul>BackboneConnPP</ul></li><br>

<h4><b>Composed Of Logical and Is PartOf</b></h4>
<p>Composed Of Logical and Is PartOf create a logical relationship in which one object<br>
    is logically composed of other objects. The other objects, in turn, are part of the<br>
    first object. This logical relationship can be between any number of real objects,<br>
    aggregate objects, or shadow objects.<br>
    In the sample network, shadow object NETV.WECONN represents the gateway<br>
    connectors between NCP A04A54C and NCP B30A54C. It has a<br>
    ComposedOfLogical relationship with the shadow objects V01LG01 and V63LG01.<br>
    These GMFHS_Shadow_Objects_Class objects in turn have an IsPartOf relationship<br>
    with the GMFHS_Shadow_Objects_Class object NETV.WECONN.<br>
    If the SNA topology manager is installed, the ComposedOfLogical relationship can<br>
    be done using the SNA topology manager object instead of the shadow object.<br>
    When an operator selects the NETV.WECONN object in a view and requests more<br>
    detail, GMFHS follows the ComposedOfLogical relationship for the<br>
    NETV.WECONN object to retrieve all objects satisfying this relationship. GMFHS<br>
    builds a view consisting of these objects, and sends it to the workstation for<br>
    display. If a ComposedOfPhysical relationship is also defined on the<br>
    NETV.WECONN object, GMFHS also builds a view of that relationship and sends<br>
    it to the workstation for display.<br>
    <h4><b> Composed Of Physical and Is PartOf</b></h4>
    Composed Of Physical and Is PartOf create a physical relationship in which one<br>
    object is physically composed of other objects. The other objects are, in turn, part<br>
    of the first object.<br>
    In the sample network, the GMFHS_Aggregate_Objects_Class object named<br>
    SYSPLEX, representing an entire non-SNA network, has a ComposedOfPhysical<br>
    relationship with objects in RODM representing the host and two minicomputers,<br>
    as shown in Figure 3 on page 18. The GMFHS_Managed_Real_Objects_Class<br>
    objects in RODM representing these resources, in turn, have an IsPartOf<br>
    relationship with aggregate object SYSPLEX.<br>
    If an operator selects the SYSPLEX object in a view and asks for more detail,<br>
    GMFHS follows the ComposedOfPhysical relationship for the SYSPLEX object to<br>
    retrieve all objects satisfying this relationship from RODM, builds a view consisting<br>
    of these objects, and sends it to the workstation for display to the requesting<br>
    operator. If a ComposedOfLogical relationship is also defined on the SYSPLEX<br>
    object, GMFHS builds a view of that relationship also and sends it to the<br>
    workstation for display, along with the ComposedOfPhysical relationship.<br>
    Although ComposedOfPhysical and IsPartOf are generally used to define a<br>
    relationship between an aggregate object and underlying real objects, this is not the<br>
    only use for this relationship. For example, you can define an object of the<br>
    GMFHS_Managed_Real_Objects_Class as being composed of other<br>
    GMFHS_Managed_Real_Objects_Class objects. In this case no aggregation occurs,<br></p>

    <hr><hr>
    <p>but if the operator selects the first object and asks for more detail, a view of the<br>
        objects that the first object is composed of is displayed.<br>
        <h4><b>AggregationParent and AggregationChild</b></h4>
        AggregationParent and AggregationChild create a relationship in which one object<br>
        is the aggregate parent for one or more aggregation children. The status of the<br>
        aggregate parent is determined by the status of the aggregation children.<br>
        The AggregationParent field of a real object links to all of the aggregate objects to<br>
        which that real object contributes status; a real object can contribute status to any<br>
        number of aggregate objects. The AggregationChild field of an aggregate object<br>
        links to all of the real objects that contribute status to that aggregate object.<br>
        You do not directly create links between the AggregationParent fields and<br>
        AggregationChild fields in the GMFHS data model. Instead, GMFHS supplies a<br>
        method, DUIFCUAP, that links these fields. For example, the following RODM<br>
        load function primitive statement links the AggregationParent field of the real<br>
        object Sysplex.PLEX1.RALXT2 to the AggregationChild field of the aggregate object<br>
        Sysplex:</p><br>
        <img src="C:\Users\Shona\Pictures\Screenshots\code1.png"><br>
        <p>The DUIFCUAP method is also used to remove these links.<br>
            <h4><b>ParentAccess and ChildAccess</b></h4>
            The ParentAccess and ChildAccess fields are used by GMFHS to build<br>
            Configuration Parents views and Configuration Children views. ParentAccess and<br>
            ChildAccess create a relationship in which one object is the parent for one or more<br>
            children objects.<br>
            When an operator selects a resource and asks for a Configuration Parents view,<br>
             GMFHS retrieves the resource from RODM and determines the resource's entire<br>
            ancestry. It then builds a view of the objects that satisfy this relationship and<br>
            displays the view at the workstation.<br>
            This relationship is often useful in hierarchically-arranged networks for<br>
            determining a path to an owner of a resource. Define both the ParentAccess and<br>
            ChildAccess relationships if you want to use either the Configuration Parents view<br>
            or the Configuration Children view.<br>
            <h4><b>PhysicalConnPP</b></h4>
            PhysicalConnPP creates a relationship in which one resource is physically<br>
            connected to another resource in a peer-to-peer relationship. This connection can be<br>
            either a node to link connection or a node to node connection. If the connection is<br>
            node to node, GMFHS inserts a null connector between the two nodes when it<br>
            displays a view containing the two objects.<br>
            In the sample network, the host in the sysplex network is connected by<br>
            PhysicalConnPP relationships to two links, which are in turn connected by<br>
            PhysicalConnPP relationships to minicomputers. When the operator selects a<br>
            resource and asks to see a view consisting of those resources that are physically<br>
            connected, GMFHS uses this relationship to build and display the view.</p><br>

            <hr><hr>
            <p>
                <h4><b>LogicalConnPP</b></h4>
                The LogicalConnPP relationship works the same way as the PhysicalConnPP<br>
                relationship, except that this relationship is logical rather than physical.<br>
                In the sample network, NCP B30A54C is connected to gateway connector V01LG01<br>
                through the LogicalConnPP relationship. Gateway connector V01LG01 is in turn<br>
                connected to NCP A04A54C by this same relationship.<br>
                <h4><b>PhysicalConnUpstream and PhysicalConnDownstream</b></h4>
                PhysicalConnUpstream and PhysicalConnDownstream are used to physically<br>
                connect objects in which direction is important. These relationships are used when<br>
                it is important to group resources at one or the other end of a connection.<br>
                For example, if you are defining a multipoint link and the resources connected to<br>
                it, you can use PhysicalConnUpstream to link a controller to the link, and<br>
                PhysicalConnDownstream to link several terminals to the link. In this case, when<br>
                the operator asked for a view showing physical connectivity, the controller is<br>
                linked at one end of the link, and the terminals are all linked at the other end.<br>
                <h4><b>LogicalConnUpstream and LogicalConnDownstream</b></h4>
                LogicalConnUpstream and LogicalConnDownstream are used to logically connect<br>
                objects in which direction is important. These relationships are the logical<br>
                counterpart of the PhysicalConnUpstream and PhysicalConnDownstream<br>
                relationships.<br>
                <h4><b>BackboneConnPP</b></h4>
                BackboneConnPP is used to show objects that are part of a subarea backbone.</p><br>
<h3 class="A"><b>Identifying Views</b></h3>
<p>
    GMFHS builds most views based on the relationships defined among the objects<br>
    that are displayed at the workstation. However, you can define four types of views<br>
    in which you specify the objects that are to be displayed: exception, network,<br>
    configuration, or more detail views. The views you define depend upon your<br>
    network.
    <h4><b>Exception Views</b></h4>
    An exception view is a collection of real, shadow, and aggregate objects that have<br>
    been defined as exceptions. No connectivity relationship is shown among these<br>
    objects. An exception view is simply a graphical list of objects. This list can be<br>
    filtered by DisplayStatus or UserStatus values of the resource object.<br>
    The following list offers just a few examples of how you can define exception<br>
    views to meet your varying business needs.<br>
To display all NCPs that are inactive.<br>
<li><ul> To display all NCPs that are inactive except for those that are being reactivated<br>
    by an automation routine.<br></ul></li>
    <li><ul> To define views that contain failing resources that are specific to an operators<br>
    area of responsibility.</ul></li><br>
    <li><ul> To show all lines that have failed.</ul></li><br>
      <li><ul> To define the time of day that a resource can be included in an exception view.</ul></li><br>
       For example, suppose you have a workstation on a token-ring LAN that is<br>
    represented as a PU. During the day, you want to monitor the workstation to<br>
    ensure that its status is satisfactory. When you turn off the workstation at the<br>
    end of the day, the status of the PU changes to unsatisfactory. Depending on</p><br>

    <hr><hr>
    <p>your exception view definition, the PU is included in an exception view. To<br>
        prevent this, you can create two definitions: one for regular hours and one for<br>
        off hours. At the end of the business day a timer starts an automation routine to<br>
        change from the regular hours definition to the off hours definition, and the PUs<br>
        is then excluded from the exception view. For more information, see “Defining<br>
        Exception View Objects and Criteria” on page 98.<br>
        Figure 7 shows an example of an exception view.<br>
        </p>
        <img src="C:\Users\Shona\Pictures\Screenshots\Figure7.png"><br>
        <p>
            <h4><b>Network Views</b></h4>
            A network view is a collection of real, aggregate, and shadow objects that the<br>
            operator is to view together. When the operator selects a network view, GMFHS<br>
            retrieves the appropriate view object from RODM and determines what objects are<br>
            specified as being part of this view. GMFHS then retrieves these objects, builds a<br>
            view containing them, and displays the view at the workstation. If the objects have<br>
            any logical or physical connectivity relationships defined among them, these<br>
            relationships are shown in the view.<br>
             Two of the network views defined for the sample network are: <br>
             <li><ul>A high-level view named BIGPIC, which shows the status of the non-SNA<br>
            components of the network at a high level.</ul></li><br>
            <li><ul> A management view named SAMPNET, which shows the major SNA and<br>
            non-SNA components of the network that are involved in managing the<br>
            non-SNA networks.</ul></li><br>
            Figure 8 on page 28 shows the high-level view named BIGPIC. In this view,<br>
             WESTCTR is an aggregate object composed of the ETHERNET and SYSPLEX<br>
            aggregate objects. EASTCTR is an aggregate object composed of aggregate objects<br>
            TRLAN and ITNM. Aggregate objects ETHERNET, SYSPLEX TRLAN, and ITNM<br>
            represent the real objects in each of the non-SNA networks being managed.<br>
            When real objects change status, their status is reflected up to aggregate objects<br>
            ETHERNET, SYSPLEX TRLAN, and ITNM, and also to aggregate objects<br>
            WESTCTR and EASTCTR. High-level view BIGPIC, therefore, presents operators<br>
            with a view that represents all of the non-SNA real objects being managed.<br>
            </p>

            <hr><hr>
            <p>If the status of WESTCTR changes from satisfactory to degraded, the operator can<br>
                select the WESTCTR object and ask for more detail. A view consisting of the<br>
                ETHERNET and SYSPLEX aggregate objects is displayed. Or the operator can<br>
                select the object and request a fast path to failing resource view. This view consists<br>
                of the real objects in the ETHERNET and SYSPLEX aggregate objects that are in an<br>
                exception state. This type of view can be valuable in a network that contains many<br>
                real and aggregate objects.</p><br>
                <img src="C:\Users\Shona\Pictures\Screenshots\Figgure8.png"><br>
                <p>Figure 9 on page 29 shows the management view named SAMPNET. This view<br>
                    displays the major SNA and non-SNA components of the network. It contains the<br>
                    SNA hosts, NCPs, and service points as well as the logical gateway connectors<br>
                    linking the two NCPs. Connected to the service points that are network<br>
                    management gateways are the aggregate objects ETHERNET, SYSPLEX, TRLAN,<br>
                    and ITNM. The SNA resources shown are defined to GMFHS as<br>
                    GMFHS_Shadow_Objects_Class objects.<br><br>
                    This view shows the major SNA and non-SNA components involved in managing<br>
                    the non-SNA networks in the sample, and the relationships among them. The<br>
                    operator can see the status of both the SNA and the non-SNA objects. If a<br>
                    non-SNA aggregate changes status, the operator can select it and ask for a more<br>
                    detailed view to find the source of the status change</p><br>

                    <hr><hr>

                    <img src="C:\Users\Shona\Pictures\Screenshots\Figure9.png"><br>
                    <p>
                       <h4><b>Configuration Views</b></h4> 
The following configuration views are predefined views. They are used to show<br>
objects in relationship to other objects.<br>
<b>View Type</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>Description</b><br>
<b>Peer</b>&nbsp;&nbsp;&nbsp;&nbsp; Displays objects that have a peer relationship.<br>
<b>Physical</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Displays objects in a network based on a physical relationship between<br>
&nbsp;&nbsp;&nbsp;&nbsp;objects.<br>
<b>Logical</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Displays objects in a network based on a logical relationship between<br>
&nbsp;&nbsp;&nbsp;&nbsp;objects.<br>
<b>Backbone</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Displays objects that constitute a subarea backbone.<br>
The following configuration views can also be dynamically built views:<br> 
<li><ul>Backbone</ul></li>
    <li><ul>Logical</ul></li>
        <li><ul>Physical</ul></li>
 </p><br>

 <hr><hr>
 <p>For more information about configuration views, see “Object Discovery Process<br>
    Description for Specific Views” on page 92. The sample network contains a<br>
    configuration peer view, which is described next.<br>
    A configuration peer view is a collection of objects that share a peer relationship in<br>
    the network displayed in a view. You specify the objects that are to appear in a<br>
    configuration peer view when you define the view. Although you can specify any<br>
    type of displayable object in a peer view, select only those objects that share a peer<br>
    relationship. It is up to you to decide which objects have such a relationship.<br>
    When the operator selects a resource in a view and asks to see any peer views in<br>
    which that object is defined, GMFHS uses the peer view objects you define to<br>
    construct the appropriate views and sends them to the requesting operator's<br>
    workstation for display. As with network views, if the objects have any logical or<br>
    physical connectivity relationships defined among them, these relationships are<br>
    shown in the view. Figure 10 on page 31 is a peer view containing three objects from the ETHERNET<br>
    network in the sample network. This view contains:<br>
    <li><ul>Connector OEMLAB</ul></li>
        <li><ul>Connector NSL_ENET</ul></li>
            <li><ul>Connector NSL_B202</ul></li><br>
    The names used in this peer view are determined by the DisplayResourceName<br>
    field of the objects. For example, the MyName value of the object displayed as<br>
    OEMLAB is LATTVIEW.656_MAIN.CNTR3000.SL02P0.<br>
    Each of the three objects in this peer view are linked to the DisplayResourceType<br>
    object DUIXC_RTN_LAN_ADAPTER. The DUIU5N01 icon and the<br>
    trapezoid-shaped terminal symbol are specified by the link to<br>
    DUIXC_RTN_LAN_ADAPTER. No relationships are defined between these objects<br>
    in the sample network definition, so none are displayed in the view.<br>
    </p>
<hr><hr>
<img src="C:\Users\Shona\Pictures\Screenshots\Figure10.png"><br>
<p>
    <h4><b>More Detail Views</b></h4>
The following more detail views are predefined views. They are used to show<br>
objects in relationship to other objects.<br>
</p>
<b>View Type</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>Description</b><br>
<b>Logical</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Displays the next lower layer of objects in a network based on a logical<br>
relationship between objects.<br>
<b>Physical</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Displays the next lower layer of objects in a network based on a physical<br>
relationship between objects.<br>
More detail views can also be dynamically built. For more information, see “More<br>
Detail Views” on page 95.<br>

<hr style="height: 1px; color: black; background-color: black;"><br>
<h3 class="A"><b>Defining Your Configuration to RODM</b></h3>
<p>You can use the SNA topology manager to define APPN and subarea networks,<br>
    and you can use MultiSystem Manager to define non-SNA resources in RODM.<br>
    You can also manually define non-SNA resources in RODM as described next.<br>
    After you identify the resources in your network that you want to monitor with<br>
    GMFHS, you then define those resources to RODM. All resources are defined in</p><br>

    <hr><hr><br>
    <p>terms of RODM load function statements and the GMFHS data model. The source<br>
        for your definition is one or more RODM load files containing the definition<br>
        statements.<br>
        This section describes how to define each of the objects you identified in the<br>
        previous section to RODM. For each type of object described previously, a<br>
        description about how that type of object is defined, the fields that must be<br>
        defined for that type of object are identified, and a sample object using the RODM<br>
        load function statements is defined. For more information about the RODM load<br>
        function statements, see Chapter 10, “Using the RODM Load Function,” on page<br>
        239.<br>
        You can create the RODM load function statements required to define your<br>
        network to GMFHS using an editor, or you can write a program to convert from<br>
        your own configuration database format to the format required by the RODM load<br>
        function.</p><br>
    <br>
<h4><b>Defining Management Objects</b></h4>
<p>Management objects include network management gateways, SNA domains, and<br>
    non-SNA domains. Create one NMG_Class object for each network management<br>
    gateway. Create one SNA_Domain_Class object for each SNA domain. Create one<br>
    or more Non_SNA_Domain_Class objects for each non-SNA domain, depending on<br>
    the specific information contained in alerts sent from the domain.<br>
    Defining SNA Domains
    Define one SNA_Domain_Class object for each SNA domain identified in your<br>
    configuration that provides access to service points that are contained in SNA<br>
    resources. This object can be displayed in a view; however, the status of<br>
    SNA_Domain_Class objects is not maintained by GMFHS.<br>
    In the sample network, SNA domain B01NV is defined by the following RODM<br>
    load function statement:</p><br>
<img src="C:\Users\Shona\Pictures\Screenshots\Code2.png"><br>
<p>The name of an SNA_Domain_Class object in RODM is the 5–character NetView<br>
    domain identifier. In this example, the SNA_Domain_Class object named B01NV is in an SNA<br>
    network named NETB. The object name is specified on the OBJINST parameter<br>
    and the network name is specified in the field SNANet of the ATTRLIST parameter<br>
    associated with the CREATE statement for this object. If you are defining more<br>
    than one SNA domain, the basic information in the definition remains the same for<br>
    each domain; you need only provide the name of the object and the SNA network<br>
    to which the domain is related.<br>
    <h4><b>Defining Network Management Gateways</b></h4>
    Create a network management gateway object for each network management<br>
    gateway in your network.</p><br>

    <hr><hr>
<p>In the sample network, the B3088P2 network management gateway is defined by
    the following RODM load function statement: </p>
    <img src="C:\Users\Shona\Pictures\Screenshots\code3.png"><br>
    <p>The name of the network management gateway object in RODM is determined as<br>
        follows: 
        <li><ul> If the gateway uses the common operator services (COS) facilities of the<br>
        NetView program to receive commands, the name of the network management<br>
        gateway object is the PU or LU name associated with the SNA resource that<br>
        contains the service point.</ul></li><br>
        <li><ul> If the gateway uses PPI interface to deliver commands and receive command<br>
        responses and alerts, the network management gateway object name is the<br>
        program-to-program interface receiver name associated with the network<br>
        management application to which the commands are sent.</ul></li><br>
        <li><ul> If the gateway uses command processors and procedures running on an OST,<br>
          the network management gateway object name can be any name that is unique<br>
        for objects of this type.</ul></li><br>
        In this example, the value of the TransportProtocolName field is COS, which<br>
        specifies that either an SSCP-PU or an LU-LU session using the common<br>
        operations services (COS) architecture is used to transport commands and alerts<br>
        between service point B3088P2 and the NetView program. The window size is 1,<br>
        specifying that only 1 command can be outstanding against the NMG.<br>
        The CommandRouteLUName field is set to B01NV, specifying that commands in<br>
        host A01MPU be routed to the service point B3088P2 by a RMTCMD command,<br>
        which specifies that the commands are first sent over a NetView-NetView session<br>
        to the NetView program residing in host B01MPU. This NetView program sends a<br>
        RUNCMD command to service point B3088P2 and routes responses back to the<br>
        NetView program in host A01MPU.<br>
        The TransportProtocolName field specifies how GMFHS communicates with the<br>
        network management gateway when delivering commands and accepting<br>
        responses to commands. Valid values for this field are:<br>
        <li><ul>COS</ul></li>
        <li><ul>PPI</ul></li>
        <li><ul>OST</ul></li>
        <li><ul>NONE</ul></li>
        </p>
        <hr><hr>
        <h4><b>Defining Non-SNA Domains</b></h4>
        <p>
            Define one Non_SNA_Domain_Class object for each unique combination of service<br>
            point (SP), transaction program (TP), and element management subsystem (EMS)<br>
            in your network. The following combinations uniquely specify an object of the<br>
            Non_SNA_Domain_Class:<br>
            <li><ul>SP</ul></li>
                <li><ul>SP.TP</ul></li>
                    <li><ul>SP.TP.EMS</ul></li>
                        <li><ul>TP</ul></li>
                            <li><ul>TP.EMS</ul></li>
        <br>
            Note that only the first three entries in the preceding list are valid for the<br>
            DOMS010 session protocol.<br>
            The value of the DisplayStatus field of an object in the Non_SNA_Domain_Class<br>
            represents the status of the command and response communication session<br>
            between GMFHS and the transaction program associated with the domain. It does<br>
            not indicate whether the transaction program is able to forward alert information<br>
            about the domain to GMFHS. For more information about alert handling, see<br>
            Chapter 6, “Customizing GMFHS to Process and Receive Alerts and Resolutions,”<br>
            on page 165.<br>
            In the sample network, Non_SNA_Domain_Class object RTP1 is defined by the<br>
            following RODM load function statement: </p><br>


            <img src="C:\Users\Shona\Pictures\Screenshots\code44.png"><br>
            <p>In this example the following field values are specified for the object of the<br>
                Non_SNA_Domain_Class:
                <li><ul>The MyName field consists of three names, separated by periods:<br></ul></li> 
                 – The name of the service point (A0488P31) <br>
                 – The name of the transaction program (A94306F8) <br>
                 – The name of the element management subsystem (RTP1)<br>
                 <li><ul>The element management subsystem contains only the element management<br>
                domain name; RTP1 in this example.<br>
                  The DomainCharacteristics field specifies:<br></ul></li> 
                – The transaction program NAP supports native commands, display status,<br>
                activate, and deactivate commands.<br>
                – Resource name elements are concatenated with periods building the full name<br>
                of the reported-on resource.<br>
                – The transaction program returns responses for commands.</p><br>

<hr><hr>
<p>– The soliciting of resource status of real objects in the domain is suppressed.<br>
     v The InitialResourceStatus field specifies that a satisfactory status is reported for<br>
    resources managed by transaction program NAP until the actual resource status<br>
    is reported by alerts or by response to a command.<br>
    <li><ul>The PresentationProtocolName field specifies DOMP020. The DOMP020 protocol<br>
    specifies that GMFHS substitutes a command string for each generic command.</ul></li><br>
    GMFHS uses the command string from the object of<br>
    GMFHS_Managed_Real_Objects_Class that is the target of the generic command,<br>
    or from the object of the Non_SNA_Domain_Class that is the domain of the<br>
    target of the generic command. For example, GMFHS substitutes the value of<br>
    the ActivateCommandText field when an activate generic command is selected.<br><br>
    <li><ul> The SessionProtocolName field specifies PASSTHRU, which means that GMFHS<br>
    assumes a session exists with the transaction program associated with this<br>
    domain.</ul></li><br><br>
    <li><ul>The ReportsToAgent field specifies that the domain is associated with the service<br>
    point and the NMG_Class object defined for that service point (A0488P31).<br>
    Because in this sample the domain is not displayed in any views, no connectivity<br>
    is defined for it.</ul></li><br>
    </p>

    <h3 class="A"><b>Defining Managed Objects</b></h3>
    <p>Managed objects include SNA resources, non-SNA real resources, and aggregate<br>
        resources. You can use the SNA topology manager to load SNA objects into<br>
        RODM, or you can manually define GMFHS_Shadow_Objects_Class objects using<br>
        the process described next. This section describes how to define these resources to<br>
        RODM.<br>
        Note: Because the alerts sent to the NetView program identify resources that have<br>
        changed status, assign names to managed objects that match the names that are<br>
        supplied by the alerts. For information about how GMFHS uses resource names<br>
        from alerts, see Chapter 6, “Customizing GMFHS to Process and Receive Alerts<br>
        and Resolutions,” on page 165.</p><br>
        <h4><b>Defining SNA Resources</b></h4>
        <p>Define one object of the GMFHS_Shadow_Objects_Class for each SNA resource<br>
            that you want to define to RODM. Although the status of SNA resources is not<br>
            stored in RODM, you might want to define SNA resources to RODM for one or<br>
            more of the following reasons:<br>
            <li><ul>To show the relationship between SNA and non-SNA resources</ul></li>
                <li><ul>To obtain alert history for SNA resources</ul></li>
                    <li><ul>To obtain SNA alert pending user status</ul></li><br>
             
            In the sample network, the shadow object for SNA host B01MPU is defined by the<br>
            following RODM load function statement: </p><br>
            <img src="C:\Users\Shona\Pictures\Screenshots\Code5.png"><br>
            <hr><hr>

            <img src="C:\Users\Shona\Pictures\Screenshots\Code6.png"><br>
            <p>The name of a shadow object is the SNA network name of the network that<br>
                contains the SNA object, a period (.), and the SNA name of the resource. In this<br>
                example, the name is NETB.B01MPU.<br>
                In this example, the host B01MPU has a DisplayResourceName of B01MPU; this<br>
                name is displayed next to the resource in all views that contain the resource. The<br>
                shadow object is assigned the DisplayResourceType of DUIXC_RTS_HOST, indicating that it is an SNA Host.<br>
                You do not define the relationships for GMFHS_Shadow_Objects_Class objects<br>
                when defining the objects themselves, but do so only after all objects are defined.<br>
                Therefore, linkages to other objects are defined later in this section.</p><br>
                <h4><b>Defining Non-SNA Real Resources</b></h4>
                <p>Define an object of the GMFHS_Managed_Real_Objects_Class for each non-SNA<br>
                    real resource you want to define to RODM. The name of this object is used to<br>
                    correlate alerts received for the resource to the object that represents the resource.<br>
                    If you added child classes to the GMFHS_Managed_Real_Objects_Class, you need<br>
                    to create fields and objects on the child classes instead. Refer to the IBM Tivoli<br>
                    NetView for z/OS Data Model Reference for more information.<br>
                    If the object you are defining is to be displayed in predefined network,<br>
                    configuration, or more detail views using certain layout algorithms, you might<br>
                    need to define an object of the Layout_Parameters_For_Object_Class for this object.<br>
                    The definition of the Layout_Parameters_For_Object_Class object is described in<br>
                    “Defining Layout Parameters for Network, Configuration, and More Detail Views”<br>
                    on page 45.<br>
                    In the sample network, the z/OS system RALXT1 is a real resource residing in the<br>
                    Sysplex network. RALXT1 is defined to RODM as a<br>
                    GMFHS_Managed_Real_Objects_Class object by the following RODM load<br>
                    function statement:</p><br>
                    <img src="C:\Users\Shona\Pictures\Screenshots\Code7.png"><br>
                    <p>The name of a GMFHS_Managed_Real_Objects_Class object is used to resolve<br>
                        alerts coming in for the real resource. It consists of the character string specified in<br>
                        the EMDomain field of the Non_SNA_Domain_Class object representing the<br>
                        non-SNA domain in which the real resource resides, and the name of the resource<br>
                        as known to its transaction program and element management system, separated<br>
                        by a period.</p><br>
                        <hr><hr>
                        <p>
                            In this example, the z/OS system is associated with the Non_SNA_Domain_Class<br>
object B3088P2.NAP.SYSPLEX, and is given a DisplayResourceType of<br>
DUIXC_RTN_STM_SYSTEM. Because the DisplayResourceName field is specified,<br>
the name that is displayed to the operator in conjunction with this resource when<br>
it is displayed in views is RALXT1.<br>
The link between an object of the GMFHS_Managed_Real_Objects_Class and an<br>
object of the Display_Resource_Type_Class is created by a RODM load function<br>
primitive statement that triggers the DUIFCLRT method. RODM load function<br>
primitive statements are described in “Load Function Primitive Statements” on<br>
page 243. The DUIFCLRT method is described in “DUIFCLRT: Link Resource Type<br>
Method” on page 497.<br>

<h4><b>Defining GMFHS Aggregate Objects</b></h4>
Aggregate objects can be used to group resources into a higher-level resources for<br>
monitoring purposes. You can also use exception views to monitor the resources<br>
directly. For more information, see “Defining Exception View Objects and Criteria”<br>
on page 98.<br>
Define one GMFHS_Aggregate_Objects_Class object for each aggregate object that<br>
you want to display in a view. If you have added child classes to the<br>
GMFHS_Aggregate_Objects_Class, you need to create objects of the child classes<br>
instead. To define a GMFHS aggregate object:<br>
<li><ul>Specify the composite relationships of the elements of the aggregate object.</ul></li>
    <li><ul>Specify which resources belong to the aggregate object.</ul></li>
        <li><ul> Set up the hierarchies between the aggregation parent and the aggregation<br>
children.</ul></li><br>
The sample network contains a SYSPLEX object that is composed of real resource<br>
representing the sysplex as a whole, two z/OS systems, and two links between the<br>
z/OS systems and the sysplex, as illustrated in Figure 3 on page 18. An aggregate<br>
object, named SYSPLEX, is defined to represent the sysplex network. The SYSPLEX<br>
aggregate object is included in a high-level view, and its status represents the<br>
collective status of the resources it represents. The<br>
GMFHS_Aggregate_Objects_Class object for the network SYSPLEX is defined by<br>
the following RODM load function statements: <br>
                        </p>
<img src="C:\Users\Shona\Pictures\Screenshots\code8.png"><br>
<hr><hr>
<img src="C:\Users\Shona\Pictures\Screenshots\code9.png"><br>
<p>The definition of an aggregate object involves two sets of relationships: the<br>
    ComposedOfPhysical and IsPartOf relationship, and the AggregationParent and<br>
    AggregationChild relationship. The ComposedOfPhysical and IsPartOf relationship<br>
    determines which objects are displayed in a view when the operator selects an<br>
    object in another view and asks for more detail. The AggregationParent and<br>
    AggregationChild relationship determines which real resources are used to<br>
    calculate the status of an aggregate resource.<br>
    In this example, the ComposedOfPhysical field of the SYSPLEX aggregate object is<br>
    linked to the IsPartOf fields of the following GMFHS_Managed_Real_Objects_Class<br>
    objects:<br>
    <li><ul>SYSPLEX.PLEX1</ul</li>
        <li><ul> SYSPLEX.PLEX1.RALXT1</ul></li>
            <li><ul>SYSPLEX.PLEX1.RALXT2</ul></li>
                <li><ul>SYSPLEX.PLEX1.LINK1</ul></li>
                    <li><ul>SYSPLEX.PLEX1.LINKS</ul></li><br><br>
    This ComposedOfPhysical and IsPartOf relationship specifies that GMFHS is to<br>
    construct a view consisting of the specified GMFHS_Managed_Real_Objects_Class<br>
    objects and display that view at the workstation when the operator selects the <br>
    object in a view and asks for more detail.<br><br>
    The SYSPLEX aggregate object is assigned a DisplayResourceType of<br>
    DUIXC_RTN_STM_SYSPLEX_AGG, which indicates that the object represents a<br>
    non-SNA aggregate host. The link between an object of the<br>
    GMFHS_Aggregate_Objects_Class and an object of the<br>
    Display_Resource_Type_Class is created by a RODM load function primitive<br>
    statement that triggers the DUIFCLRT method. The DUIFCLRT method is<br>
    described in “DUIFCLRT: Link Resource Type Method” on page 497.<br><br>
    The SYSPLEX object is an aggregate host that represents the underlying real<br>
    resources in the sysplex network. An AggregationParent and AggregationChild link<br>
    is created between this aggregate parent and its aggregate children by RODM load<br>
    function primitive statements using the DUIFCUAP method. The DUIFCUAP<br>
    method is described in “DUIFCUAP: Update Aggregation Path Method” on page<br>
    499.</p><br>

    <hr><hr>

    <p>In general, the ComposedOfPhysical and IsPartOf relationship and the<br>
        AggregationParent and AggregationChild relationship are used in conjunction;<br>
        however, they can be used separately. For example, if you wanted a real resource<br>
        to appear in a more detailed view for an aggregate resource but did not want it to<br>
        contribute to the status of the aggregate resource, you can define the<br>
        ComposedOfPhysical and IsPartOf relationship for the aggregate object and real<br>
        object pair, but not define the AggregationParent and AggregationChild<br>
        relationship.<br>
        As another example, you might want to define a<br>
        GMFHS_Managed_Real_Objects_Class object as being composed of other<br>
        GMFHS_Managed_Real_Objects_Class objects. Then, when the user selects the first<br>
        object and asks for more detail, the objects that are defined as part of the first<br>
        object are displayed. Because the first object is not an aggregate object, the<br>
        AggregationParent and AggregationChild relationship is not defined in this case.</p><br>

        <h3 class="A"><b>Defining Connectivity Relationships Between Objects</b></h3>
        <p>Connectivity relationships between objects can determine which objects appear in<br>
            views and which resources contribute to the status of aggregate objects. With the<br>
            exception of relationships involving shadow objects, these connectivity<br>
            relationships, described in “Identifying Connectivity Relationships” on page 23, can<br>
            be defined when the objects are defined or any time after the objects are defined.<br>
            Connectivity relationships that include shadow objects can be defined only after<br>
            the shadow objects have been defined. This section illustrates how to define some<br>
            of these relationships using examples from the sample network.<br>
            <h4><b>Defining Logical Connectivity</b></h4>
            Objects can be connected with logical links using the LogicalConnPP field or the<br>
            LogicalConnUpstream and LogicalConnDownstream fields of the objects that are to<br>
            be connected. In the sample network, the shadow object that represents SNA host<br>
            B01MPU is logically connected to the shadow object that represents SNA NCP<br>
            B30A54C to create the relationship illustrated in Figure 9 on page 29 by using the<br>
            following RODM load function statement:</p><br>
            <img src="C:\Users\Shona\Pictures\Screenshots\code10.png"><br>
            For each object that is to be linked, the class information for the object, the object<br>
name, and the field that determines the type of link that is being defined needs to<br>
be specified.<br>
<h4><b>Defining Physical Connectivity</b></h4>
Objects can be connected with physical links by using the PhysicalConnPP field or<br>
the PhysicalConnUpstream and PhysicalConnDownstream fields of the objects that<br>
are to be connected. In the sample network, non-SNA host RALV4 is physically<br>
linked to link LINK1 by using the following RODM load function statements: <br>
            <img src="C:\Users\Shona\Pictures\Screenshots\code11.png"><br>
            <p>For each object that is to be linked, the class information for the object, the object<br>
                name, and the field that determines the type of link that is being defined needs to<br>
                be specified.</p><br>

                <hr><hr>
        
    <h4><b>Defining Parent-Child Relationships</b></h4>
    
<p>Parent and Child links are defined using the ChildAccess and ParentAccess fields<br>
of the objects that are to be linked. In the sample network, the z/OS system<br>
RALXT1 is linked to the sysplex in the configuration illustrated in Figure 3 on page<br>
18 by using the following RODM load function statement:</p><br>
<img src=""><br>
<p>For each object that is to be linked, the class information for the object, the object<br>
    name, and the field that determines whether the object is the parent or the child<br>
    needs to be specified.<br>
    <h3 class="A"><b>Defining Views</b></h3>
    The following kinds of views can be defined in RODM:<br>
    <li><ul>Exception</ul></li>
        <li><ul>Network</ul></li>
            <li><ul>Configuration</ul></li>
                <li><ul>More detail</ul></li><br>
    When defining view objects, always use the RODM high-level load function<br>
    statements. RODM high-level load function statements allow all fields on the object<br>
    to be defined before the object is used. If RODM primitive statements are used,<br>
    GMFHS might attempt to access information about the view object before all of the<br>
    information is defined, and this can result in unexpected errors. For more<br>
    information about high-level load function and primitive statements, see to<br>
    Chapter 10, “Using the RODM Load Function,” on page 239.<br>
    The views that are constructed in RODM are displayed by the NetView<br>
    management console. The following sections describe parameters and layout<br>
    algorithms that are used by the graphic facility. See Appendix B, “View Layout<br>
    Facility,” on page 673 for more information about views.<br>
    <h4><b>Defining Exception Views</b></h4>
    Exception views are represented by objects in the Exception_View_Class. Create<br>
    one object in this class for each exception view you want to display. Use the<br>
    NetView management console to display a list of all defined views.<br>
    The sample network does not include an exception view. However, sample<br>
    DUIFDEXV provides an example of defining exception view objects, and the<br>
    RODM load function statements in this section can be used to define an exception<br>
    view. Figure 11 on page 41 shows an exception view of all objects in the<br>
    GMFHS_Displayable_Objects_Parent_Class that have DisplayStatus of either<br>
    severely degraded or unsatisfactory</p><br>
<hr><hr>
<img src="C:\Users\Shona\Pictures\Screenshots\Figure11.png"><br>
The exception view EXCEPTIONVIEW1 is defined by the following RODM load<br>
function statement:<br>

<img src="C:\Users\Shona\Pictures\Screenshots\Code13.png"><br>
<p>Use the following statement to define all objects of the class<br>
    GMFHS_Displayable_Objects_Parent_Class to be in EXCEPTIONVIEW1. Note that<br>
    you do not have to define ExceptionViewList fields at the class level. You can also<br>
    define the ExceptionViewList field at the object level.<br>
    </p>
    <img src="C:\Users\Shona\Pictures\Screenshots\Code14.png"><br>
    <p>For more information defining objects to exception views, see “Defining Exception<br>
        View Objects and Criteria” on page 98.<br>
        <h4><b>Defining Network Views</b></h4>
        Network views are represented by objects in the Network_View_Class. Create one<br>
        object in this class for each network view you want to display. The NetView<br>
        management console can display a list of all defined views.<br>
        Figure 12 on page 42 shows a network view of the SYSPLEX network component<br>
        of the sample network. The icon and symbol displayed for each object are<br>
        determined by the DisplayResourceType object to which it is linked.<br>
         For example,
        the resource SYSPLEX.PLEX1.RALXT1 is linked to DUIXC_RTN_STM_SYSTEM.<br>
        The icon DUIUEB2B and the square-shaped host symbol are specified by<br>
        DUIXC_RTN_STM_SYSTEM. The name RALXT1 shown in the view is specified by<br>
        the DisplayResourceName field of object SYSPLEX.PLEX1.RALXT1.</p><br>

        <hr><hr>
        <img src="C:\Users\Shona\Pictures\Screenshots\Figure12.png"><br>
        <p>The network view of the sysplex network is defined by the following RODM load<br>
            function statement:</p><br>
            <img src="C:\Users\Shona\Pictures\Screenshots\code15.png"><br>
            <p>In this example, a Network_View_Class object named SYSPLEX is defined to<br>
                represent the network view of the sysplex network. The Annotation field of the<br>
                object is assigned the value SYSPLEX NETWORK, which is displayed at the workstation<br>
                with the view. The ContainsObjects field of the SYSPLEX object is linked to the<br>
                ContainedInView fields of the managed real objects that represent the real<br>
                resources that make up the SYSPLEX network.<br><br>
                <h4><b>Defining Configuration Views</b></h4>
                Configuration views are created by defining an object to represent the view on one<br>
                of the following classes:<br>
                <b>View Type</b><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<b>Class Defined</b><br>
        <b>Peer</b>&nbsp;&nbsp;&nbsp;&nbsp; Configuration_Peer_View_Class<br>
    <b>Physical</b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;Configuration_Physical_Connectivity_View_Class<br>
                </p>

                <hr><hr>

                <b>Logical</b>&nbsp;&nbsp;&nbsp;&nbsp; Configuration_Logical_Connectivity_View_Class<br>
    <b>Backbone</b>&nbsp;&nbsp;&nbsp;&nbsp;Configuration_Backbone_View_Class<br>
<p>Create one object on its respective class for each configuration view you want to<br>
    display. Because the sample network contains a configuration peer view, an<br>
    example of defining a Configuration_Peer_View_Class object follows. Use a similar<br>
    procedure to define objects on any of the other configuration view type classes.<br>
    The following configuration views can also be dynamically built views:<br>
    <li>
        <ul>
     Backbone
     Logical
      Physical
    </ul>
    </li>
    For more information about configuration views, see “Object Discovery Process<br>
    Description for Specific Views” on page 92.<br>
    <b>Defining Peer Views:</b> Figure 13 on page 44 is a peer view of the token-ring LAN<br>component. Peer views are represented by objects in the<br>
    Configuration_Peer_View_Class. Create one object in this class for each peer view<br>you want to display.<br><br>
     Figure 13 on page 44 is a peer view of the token-ring LAN component of the<br>
    sample network. The icon and symbol displayed for each object are determined by<br>
    the DisplayResourceType object to which it is linked. For example, the aggregate<br>
    resource BRIDGE01 is linked to DUIXC_RTN_BRIDGE_AGG. The icon DUIU4N02<br>
    and the hexagon-shaped node symbol are specified by<br>
    DUIXC_RTN_BRIDGE_AGG. Because BRIDGE01 is an aggregate resource, the<br>
    node symbol contains the smaller aggregate symbol as well. The name BRIDGE01<br>
    shown in the view is specified by the DisplayResourceName field of object<br>
    BRIDGE01.<br>
    Note that the sample network defines a real object named LANMGR.BRIDGE01<br>
    that also has a DisplayResourceName value of BRIDGE01. The BRIDGE01 in this<br>
    view is an object of the GMFHS_Aggregate_Objects_Class.<br>
    </p>
    <hr><hr>
    <img src="C:\Users\Shona\Pictures\Screenshots\Figure13.png"><br>
    The configuration peer view of the token-ring LAN network is defined by the<br>
following RODM load function statement:<br>
<img src="C:\Users\Shona\Pictures\Screenshots\Code16.png"><br>
In this example, a Configuration_Peer_View_Class object named TRLANNET_Peer<br>
is defined to represent the configuration peer view of the token-ring LAN network.<br>
The Annotation field of the object is assigned the value <i>Token Ring Network;</i> the<br>
<hr><hr>
<p>Layout Type field is assigned the value 4, which specifies radial layout for<br>
token-ring networks. The ConnType field is assigned value 80, as in the previous<br>
network view example.<br>
When you create a view, you specify the object names of the objects that appear in<br>
the view. The object names in the RODM load function statements in this example<br>
are different from the names shown in Figure 13 on page 44, because the sample<br>
network uses the DisplayResourceName field to specify the name that is displayed<br>
for each resource in the token-ring network. For example, the object<br>
LANMGR.10005AC35CA0 has its DisplayResourceName field set to A0488P21.<br>
The FirstNode field of the TRLANNET_Peer object is linked to the IsFirstNode<br>
field of the object that is to be displayed at the top of the ring in the configuration<br>
peer view. The SecondNode field links to the object that is to be displayed to the<br>
right of the first node in the view. The ContainsObjects field links to the remaining<br>
objects that are to be displayed in the view. These objects are displayed in the view<br>in the order in which they are defined.<br></p>
<b>Defining More Detail Views</b><br>
More detail views are created by defining an object to represent the view on one of<br>
the following classes:<br>
<b>View Type</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>Class Defined</b><br>
<b>Physical</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;More Detail_Physical_View_Class<br>
<b>Logical</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;More Detail_Logical_View_Class<br>
Create one object on its respective class for each more detail view you want to<br>
display. Note that these views can also be dynamically built views.<br>
The sample network does not include a predefined more detail view. For more<br>
information about more detail views, see “More Detail Views” on page 95.<br>
<h3 class="A"><b>Defining Layout Parameters</b></h3>
Layout parameters can be specified for the following types of views:<br>
<li><ul>Network</ul></li>
    <li><ul>Configuration</ul></li>
        <li><ul>More detail</ul></li>
            <li><ul> Exception</ul></li><br>
<h4><b>Defining Layout Parameters for Exception Views</b></h4>
The grid layout is the only layout algorithm that can be used with exception<br>
views, and the only view parameter that can be defined for the grid layout<br>
algorithm is layout width. For information about the grid layout algorithm, see<br>
Appendix B, “View Layout Facility,” on page 673.<br>
<h4><b>Defining Layout Parameters for Network, Configuration, and<br>
More Detail Views</b></h4><br>
When you define a network, configuration, or more detail view, you can specify<br>
the layout algorithm. You do this by specifying a value in the LayoutType field of<br>
the view object you define to represent the view. You can define view objects for<br>
the following classes:<br>

<hr><hr>

<p>
    <li><ul>Network_View_Class</ul></li>
        <li><ul>Configuration_Peer_View_Class</ul></li>
            <li><ul> Configuration_Backbone_View_Class</ul></li>
                <li><ul>Configuration_Logical_Connectivity_View_Class</ul></li>
                    <li><ul>Configuration_Physical_Connectivity_View_Class</ul></li>
                        <li><ul>More_Detail_Logical_View_Class</ul></li>
                            <li><ul>More_Detail_Physical_View_Class</ul></li><br>
    If you do not specify a layout algorithm, the default radial by link type layout<br>
    algorithm is used.<br>
    For information about choosing the kind of layout algorithm to use and the<br>
    advantages and disadvantages of each layout algorithm, see Appendix B, “View<br>
    Layout Facility,” on page 673.<br>
    Certain layout algorithms require that you provide additional information to help<br>
    it lay the view out correctly. Sometimes this information is specified in the fields of<br>
    the view object itself; for example, the LinkCrossOptionValue field specifies the<br>
    amount of effort the radial layout algorithm is to expend trying to untangle<br>
    crossed links. As another example, the FirstNode and SecondNode fields specify<br>
    which node is to be placed at the top of the ring, and which node is to be placed<br>
    to the right of the top node, in the radial layout algorithm for token rings.<br>
    Additional information can also be specified in the fields of<br>
    Layout_Parameters_For_Object_Class objects. These objects link a view and an<br>
    object that is to be displayed in the view. They specify parameters that apply when<br>
    that object is laid out in a particular view by a particular layout algorithm. One<br>
    Layout_Parameters_For_Object_Class object can be linked to all objects that have<br>
    the same layout parameters.<br>
    Examples are the RootNode field, which specifies that the resource linked to this<br>
    Layout_Parameters_For_Object_Class object is to be the root node in a connectivity<br>
    tree when the connectivity tree layout is used, and the LayoutSequence field,<br>
    which specifies for certain layout algorithms where an object linked to this<br>
    Layout_Parameters_For_Object_Class object appears in a sequence of objects.<br>
    Table 1 on page 47 lists the fields that can be specified on objects of the following<br>
    classes:<br>
    <li><ul>Network_View_Class</ul></li><br>
    <li><ul>Configuration_Peer_View_Class</ul></li><br>
        <li><ul>Configuration_Backbone_View_Class</ul></li><br>
            <li><ul>Configuration_Logical_Connectivity_View_Class</ul></li><br>
                <li><ul>Configuration_Physical_Connectivity_View_Class</ul></li><br>
                    <li><ul>More_Detail_Logical_View_Class</ul></li><br>
                        <li><ul>More_Detail_Physical_View_Class</ul></li><br>
    These fields can be optional, required, or not applicable, depending on the layout<br>
    algorithm that is being used. Table 1 on page 47 indicates the optional (O) and<br>
    required (R) fields. N/A indicates that the parameter is not applicable for that type<br>
    of layout algorithm.</p><br>

    <hr><hr>
    <i>Table 1. Layout Algorithms and View Parameters</i><br>
    <table border="1" cellpadding="1" cellspacing="1">
        <tr><td><b>Layout Algorithm</b></td><td><b>Link
            Cross
            Option
            Value</b></td><td><b>Bin
                Packing
                Flag</b></td><td><b>Bus
                    Node</b></td><td><b>First
                        Node</b></td><td><b>Second
                            Node</b></td><td><b>Layout
                                Orientation</b></td><td><b>Default
                                    Row
                                    Spacing</b></td><td><b>Ellipse
                                        Aspect
                                        Ratio
                                        Width/
                                        Height</b></td><td><b>Layout
                                            Width</b></td></tr>
            <tr><td>Radial by cluster ID</td><td> O</td><td> O</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>Radial by link type</td><td> O</td><td> O</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>Local area net</td><td> O</td><td> O</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>Token-ring net</td><td>N/A</td><td>N/A</td><td>N/A</td><td>R</td><td>R</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>LAN with central bus</td><td>N/A</td><td>N/A</td><td>R</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>Hierarchical with
                proximity</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>O</td><td>O</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>Single ellipse</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>O</td><td>N/A</td></tr>
            <tr><td>Connectivity tree</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>O</td><td>O</td><td>N/A</td><td>N/A</td></tr>
            <tr><td>Grid</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>O</td></tr>
    </table>
    <p>For information about the layout parameters and about the layout algorithms, see<br>
        Appendix B, “View Layout Facility,” on page 673.<br>
        Layout Parameters: Table 2 lists the layout parameters that can be specified on<br>
        Layout_Parameters_For_Object_Class objects and indicates for which type of layout<br>
        algorithms the layout parameters are optional (O) or required (R). N/A indicates<br>
        that the parameter is not applicable for that type of layout algorithm. For more<br>
        information about these layout parameters and the layout algorithms, see<br>
        Appendix B, “View Layout Facility,” on page 673.</p><br>
        <i>Table 2. Layout Algorithms and Layout Parameters</i><br>
        <table border="1" cellpadding="1" cellspacing="1">
            <tr><td><b>Layout Algorithm</b></td><td><b>Resource
                Layout
                Char.</b>
                </td><td><b>Layout
                    Sequence</b></td><td><b>Hierarch.
                        Priority</b></td><td><b>Root
                            Node</b></td><td><b>Cluster
                                IDValue</b></td>

                                </tr>

<tr><td>Radial by cluster ID</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>R</td></tr>
<tr><td>Radial by link type</td><td>O</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td>Local area net</td><td> N/A</td><td> O</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td>Token-ring net</td><td>N/A</td><td>O</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td>LAN with central bus</td><td>N/A</td><td>O</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td>Hierarchical with  proximity</td><td>N/A</td><td>N/A</td><td>R</td><td>N/A</td><td>N/A</td></tr>
<tr><td>Single ellipse</td><td>N/A</td><td>O</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td>Connectivity tree</td><td>N/A</td><td>O</td><td>N/A</td><td>R</td><td>N/A</td></tr>  
    
<tr><td>Grid</td><td>N/A</td><td>O</td><td>O</td><td>N/A</td><td>N/A</td></tr>
        </table><br>
    <p>In the sample network, Layout_Parameters_For_Object_Class object LPTRLAN<br>
        contains the parameters that specify how aggregate object TRLAN is to be<br>
        displayed in network view SAMPNET, as illustrated in Figure 9 on page 29. The<br>
        following is the RODM load function statement that defines the LPTRLAN object:</p><br>
        <img src="C:\Users\Shona\Pictures\Screenshots\code17.png"><br>
        <hr><hr>
        <img src="C:\Users\Shona\Pictures\Screenshots\code18.png"><br>
        <p>The Object field specifies the object to which the layout parameters apply; the<br>
            View field specifies the view to which the layout parameters apply. The<br>
            HierarchicalPriority field specifies that the TRLAN object is to appear in the fourth<br>
            row of the hierarchical layout in the network view. <br>
            Layout_Parameters_For_Object_Class object LPB3088P2P contains the parameters<br>
            that specify how shadow object NETB.B3088P2 is to be displayed in network view<br>
            of the sysplex network, as illustrated in Figure 12 on page 42. The following<br>
            RODM load function statement defines the LPB3088P2P layout parameters object:</p><br>
            <img src="C:\Users\Shona\Pictures\Screenshots\code19.png"><br>
            <p>As in the previous example, the Object and View fields specify the object and the<br>
                view to which these parameters are associated. The LayoutSequence field is<br>
                assigned the value 0, which specifies that the nodes are to be laid out in no<br>
                particular order in the view. The RootNode field specifies that shadow object<br>
                NET.B3088P2 is to be displayed as a root node in the connectivity tree.<br>
                <h4><b>Defining Layout Parameters for Dynamically Built More Detail<br>
                Views</b></h4>
                All types of more detail views can be dynamically built. You can specify the layout<br>
                of more detail views even though you do not explicitly define the more detail<br>
                views. More detail views are created when an NetView management console<br>
                operator chooses <b>More Detail</b> from a context menu. GMFHS attempts to build the<br>
                following more detail views for objects defined in RODM:<br>
                <li><ul> The more detail logical view contains all of the objects specified by the<br>
                ComposedOfLogical field of the selected object.</ul></li><br>
                <li><ul>The more detail physical view contains all of the objects specified by the<br>
                ComposedOfPhysical field of the selected object.<br>
                <li><ul> The configuration children II view contains all of the objects specified by the<br>
                RelFieldNamesA field of the View_Information_Object_Class object for the<br>
                configuration children II view.</ul></li><br>
                <li><ul> The configuration children III view contains all of the objects specified by the<br>
                RelFieldNamesA field of the View_Information_Object_Class object for the<br>
                configuration children III view.</ul></li><br><br>
                 If the value of the ComposedOfLogical field or the ComposedOfPhysical field is<br>
                null, the corresponding view is not built. Refer to “Understanding Views” in the<br>
                IBM Tivoli NetView for z/OS User's Guide: NetView Management Console for<br>
                information about displaying more detail views.</p><br>


                <hr><hr>
                <p>You can specify layout parameters for each of the more detail views created from a<br>
                    selected object. Complete the following steps to specify layout parameters for more<br>
                    detail views. Figure 14 on page 50 shows the objects (▌A▐, ▌B▐, and ▌C▐) and links<br>
                    (▌1▐ and ▌2▐) you create.<br>
                    1. Select the object for which you want to define more-detail-view layout<br>
                    parameters. You are defining layout parameters for the more detail views<br>
                    created when this object is selected in another view.<br>
                     For this example, select the aggregate object TRLAN (▌A▐) in the sample<br>
                    network.<br>
                    2. Choose the more detail view for which you are defining layout parameters:<br>
                    more detail logical or more detail physical.<br>
                    The TRLAN object has valid values for both ComposedOfLogical and<br>
                    ComposedOfPhysical, so two more detail views are created. For this example,<br>
                    choose to define layout parameters for the more detail physical view.<br>
                     3. Create an object of the Layout_Parameters_For_View_Class to represent the<br>
                    view. Hint: Layout_Parameters_For_View_Class objects are similar to<br>
                    Network_View_Class objects.<br>
                    The following is part of the RODM load function statement that creates the<br>
                    object (▌B▐) for this example. The sample member DUIFSNET contains the<br>
                    complete statements.</p><br>
                    <img src="C:\Users\Shona\Pictures\Screenshots\code20.png"><br>
                    4. Link the SelectedResource field of the object you created in Step 3 to the<br>
DetailViewLayoutForSelectedResource field of the object you selected in Step 1.<br>
 The following is part of the RODM load function statement that creates this<br>
link, shown as ▌1▐ in Figure 14 on page 50:<br>
<img src="C:\Users\Shona\Pictures\Screenshots\code21.png"><br>
5. Specify which more detail view type this Layout_Parameters_For_View_Class<br>
object (▌B▐) represents. You specify the view type by linking the ViewClass field<br>
of this object to the DetailViewLayout field of an object (▌C▐) in the<br>
View_Information_Reference_Class that represents the view type:<br>
 <li><ul>More_Detail_Logical_View_Reference</ul></li>
 <li><ul>More_Detail_Physical_View_Reference</ul></li>
 <li><ul>Configuration_Children_II_View_Reference</ul></li>
 <li><ul>Configuration_Children_III_View_Reference</ul></li>
The following is part of the RODM load function statement that creates the link<br>
specifying a more detail physical view, shown as ▌2▐ in Figure 14 on page 50:<br>
<img src="C:\Users\Shona\Pictures\Screenshots\code22.png"><br>
6. Specify the layout parameters for the view you are defining. The remaining<br>
fields of the Layout_Parameters_For_View_Class object (▌B▐) specify the layout<br>
algorithm and other view parameters. Table 1 on page 47 lists the required<br>
parameters for each layout algorithm.<br>
For this example, choose radial layout for token ring networks as the layout<br>
algorithm. Table 1 on page 47 shows that the FirstNode field and SecondNode<br>

<hr><hr>
<p>field are required for this layout. The following is part of the RODM load<br>
    function statement that specifies the layout algorithm and the FirstNode and<br>
    SecondNode fields:<br>
    </p>
    <img src="C:\Users\Shona\Pictures\Screenshots\code23.png"><br>
    7. If you want to use this same Layout_Parameters_For_View_Class object for<br>
additional objects or views, create additional links. All of the link fields accept<br>
multiple values.<br>
8. If you need to control the layout of individual objects in the more detail view,<br>

 define layout parameters for the objects. Some layout algorithms require layout<br>
parameters for the objects: Table 2 on page 47 lists required parameters.<br>
See “Adding Layout Parameters for Objects in More Detail Views” for<br>
instructions on defining layout parameters.<br>
<img src="C:\Users\Shona\Pictures\Screenshots\figure14.png"><br>
<p><b>Adding Layout Parameters for Objects in More Detail Views:</b><br>
    <b>Note:</b> You can also define layout parameters for individual objects that appear in<br>
    more detail views. You define these layout parameters withv
    Layout_Parameters_For_Object_Class objects. Links specify which objects and<br>
    views the layout parameters apply to. Complete the following steps to specify<br>
    layout parameters for more detail views. Figure 15 on page 53 shows the objects<br>
    and links you create.<br>
    1. Identify the objects in a more detail view that you want to define layout<br>
    parameters for. The objects must be specified by the ComposedOfLogical, the</p><br>

    <hr><hr>
    <p>ComposedOfPhysical, or the RelFieldNamesA field of the original object you<br>
        specified in Step 1 on page 49 to appear in the more detail view.<br>
         For this example, define layout parameters for the object (▌E▐)<br>
        LANMGR.10005A89A267 of the GMFHS_Managed_Real_Objects_Class.<br>
        2. Create an object of the Layout_Parameters_For_Object_Class to represent the<br>
        layout parameters for the object when it is in a particular view.<br>
         The following is part of the RODM load function statement (not in the<br>
        DUIFSNET sample) that creates this object (▌D▐), shown in Figure 15 on page<br>
        53:</p><br>
        <img src="C:\Users\Shona\Pictures\Screenshots\code24.png"><br>
        3. Link the Object field of the Layout_Parameters_For_Object_Class object you<br>
created in Step 2 to the DetailLayoutParmList field of the object represented.<br>
In this example, link the Object field of the<br>
Detail_Layout_LANMGR.10005A89A267 object (▌D▐) to the<br>
DetailLayoutParmList field of the object (▌E▐) LANMGR.10005A89A267. The<br>
following is part of the RODM load function statement that creates this link,<br>
shown as ▌3▐ in Figure 15 on page 53:<br>
<img src="C:\Users\Shona\Pictures\Screenshots\code25.png"><br>
4. Specify the view that these layout parameters apply to:<br>
a. Link the SelectedResource field of the Layout_Parameters_For_Object_Class<br>
object to the DetailLayoutParmListForSelectedResource field on the object<br>
which is selected to generate this more detail view (the object selected in 1<br>
on page 49).<br>
In this example, link the SelectedResource field of object (▌D▐)<br>
Detail_Layout_LANMGR.10005A89A267 to the<br>
DetailLayoutParmListForSelectedResource field of object (▌A▐) TRLAN. The<br>
following is part of the RODM load function statement that creates this link,<br>
shown as ▌4▐ in Figure 15 on page 53:<br>
<img src="C:\Users\Shona\Pictures\Screenshots\code26.png"><br>
<p>b. Specify which more detail view type these layout parameters apply to. You<br>
    specify the view type by linking the ViewClass field of this object (▌D▐) to<br>
    the DetailLayoutParmList field of an object (▌C▐) in the<br>
    View_Information_Reference_Class that represents the view type:<br>
     <li><ul>More_Detail_Logical_View_Reference</ul></li> 
     <li><ul>More_Detail_Physical_View_Reference</ul></li> 
     <li><ul>Configuration_Children_II_View_Reference</ul></li> 
     <li><ul>Configuration_Children_III_View_Reference</ul></li> 
    The following is part of the RODM load function statement that creates the<br>
    link specifying the more detail physical view, shown as ▌5▐ in Figure 15 on<br>
    page 53:</p><br>
    <img src="C:\Users\Shona\Pictures\Screenshots\code27.png"><br>
    <p>5. Specify the layout parameters for the object. Table 2 on page 47 lists the<br>
        optional and required layout parameters for each layout algorithm.<br>
        For this example, the radial layout for token ring algorithm is used. Table 2 on<br>
        page 47 shows that the LayoutSequence field is the only optional parameter</p><br>

        <hr><hr>
        <p>you can specify. Specify a value of 3 for the LayoutSequence field of this object<br>
            (▌D▐). The following is part of the RODM load function statement that sets the<br>
            value of the LayoutSequence field:<br>
            LayoutSequence ::= (INTEGER) 3;<br>
            6. If you want to use this same Layout_Parameters_For_Object_Class object for<br>
            additional objects or views, create additional links. All of the link fields accept<br>
            multiple values.<br>
            For example, use this same object to define the layout parameters for object<br>
            LANMGR.10005A89A267 when it is in the more detail physical view generated<br>
            when an object of the GMFHS_Aggregate_Objects_Class named OTHER_AGG<br>
            is selected (OTHER_AGG is not part of the sample network).<br>
             Create a link fromthe SelectedResource field of object Detail_Layout_LANMGR.10005A89A267 to<br>
            the DetailLayoutParmListForSelectedResource field of object OTHER_AGG. The<br>
            following is a RODM load function primitive statement that creates this link:</p><br>

            <img src="C:\Users\Shona\Pictures\Screenshots\code28.png"><br><br><br><br><br><br><br>
            <hr><hr>
            <br><br><br>
            <img src=""><br>
            <h3 class="A"><b>Putting It All Together</b></h3>
                <p>After you have defined the objects that represent your configurations and<br>
                networks, load them into RODM using the RODM load function. Chapter 3,<br>
                “Loading the GMFHS Data Model,” on page 55 contains directions for doing this.<br>
                You need to load the class definition before you load the definitions of the objects<br>
                of that class. By the same token, you need to define objects that are to be linked</p><br><br><br><br>
                <br><br>

                <hr><hr>
                <p>before you can actually link them. Use the load function statements in sample<br>
                    member DUIFSNET as an example of the order to follow. The objects and links in<br>
                    the sample network are arranged for loading in the following order:<br>
                    1. SNA_Domain_Class objects<br>
                    2. GMFHS_Shadow_Objects_Class objects<br>
                    3. NMG_Class objects<br>
                    4. Non_SNA_Domain_Class objects<br>
                    5. GMFHS_Managed_Real_Objects_Class objects<br>
                    6. GMFHS_Aggregate_Objects_Class objects<br>
                    7. Linkages among objects<br>
                    <li><ul>Logical links</ul></li>
                    <li><ul>Physical links</ul></li>
                    <li><ul>Parent/Child links</ul></li>
                    8. Exception_View_Class objects<br>
                    9. Network_View_Class objects<br>
                    10. Configuration_Peer_View_Class objects<br>
                    11. Layout_Parameters_For_View_Class objects<br>
                    12. Layout_Parameters_For_Object_Class objects<br>
                    <b>Note:</b> Although the sample network defined in sample load file DUIFSNET does<br>
                    not include an exception view, it is included in the preceding list in the position<br>
                    that it must be loaded.<br>
                    Study the network in the sample load file DUIFSNET carefully before defining<br>
                    your own network. For information about RODM load function syntax, see<br>
                    Chapter 10, “Using the RODM Load Function,” on page 239.<br>
                    </p>
                    <br><br><br><br><br><br><br><br><br><br><br>
                    <hr><hr>
<br><br><br>
                    <hr style="height: 1px; color: black; background-color: black;"><br>
                    <h3 class="A"><b>Chapter 3. Loading the GMFHS Data Model</b></h3>
                    <p>This chapter describes how to load the GMFHS and SNA topology manager data<br>
                        models, your network definition, and methods into RODM. This chapter also<br>
                        describes how to make additions, changes, or deletions to objects when GMFHS is<br>
                        active.<br>
                        The GMFHS class structure is provided in RODM load function input file,<br>
                        DUIFSTRC, which is shipped with the NetView program.<br>
                        The class structure for the SNA topology manager is provided in RODM load<br>
                        function input files, FLBTRDMx, which is also shipped with the NetView program.<br>
                        For more information about the FLBTRDMx load function input files, refer to <i>IBM<br>
                            Tivoli NetView for z/OS Installation: Configuring Graphical Components.</i><br>
                             DUIFSTRC and all the FLBTRDMx input files are loaded using sample CNMSJH12.<br>
                        Both the DUIFSTRC and all of the FLBTRDMx input files must be loaded for<br>
                        GMFHS operation. Note that input file DUIFSTRC must be loaded before any<br>
                        FLBTRDMx input files are loaded. This is the order specified in sample CNMSJH12<br>
                        and it must not be changed.</p><br><br>
                        <hr style="height: 1px; color: black; background-color: black;"><br>
                        <h3 class="A"><b>Loading the Data Models and Network Definitions</b></h3>
                        <p>With RODM running, use sample CNMSJH12 to load the GMFHS data model and<br>
                            your network definition.<br>
                            1. Create RODM statements to define your non-SNA network. See Chapter 2,<br>
                            “Defining Your Network to GMFHS,” on page 15 for information about how to<br>
                            define your network to RODM.<br>
                            2. Update the sample job CNMSJH12 as follows:<br>
                            a. Change the JOB statement to specify your installation's accounting<br>
                            information.<br>
                            b. Enter the names of the RODM load files that were created in Step 1 into the<br>
                            EKGIN1 DD statement on the last line of the sample. For example, if your<br>
                            object definitions are in the data set NETVIEW.MYDEFS(OBJECTS), the last<br>
                            line of CNMSJH12 is:<br>
                            // DD DSN=NETVIEW.MYDEFS(OBJECTS),DISP=SHR<br>
                            c. Replace RODMNAME with the name of your RODM in the EXEC statement.<br>
                            3. Ensure that RODM is running.<br>
                            4. Start CNMSJH12.<br>
                            5. Start GMFHS.</p><br>
        <hr style="height: 1px; color: black; background-color: black;"><br>
      <h3 class="A"><b>Changing Network Definitions When GMFHS Is Running</b></h3>
      <p>If GMFHS is running when non-SNA objects are to be added, changed, or deleted<br>
        in the RODM data cache, the GMFHS CONFIG command might be required. The<br>
        GMFHS CONFIG command identifies, to GMFHS, the scope of the changes and<br>
        the type of processing needed to respond to them.<br>
        Subarea resources that are managed by SNA topology manager can be changed<br>
        anytime without using the GMFHS CONFIG commands.</p><br><br><br><br><br>
        <hr><hr>

        <br><br>
        <p><b>Note:</b><br>
            1. NMGs and domains can be added dynamically without using the GMFHS<br>
            CONFIG command. See “Adding NMGs and Domains When GMFHS Is<br>
            Active” on page 58 for more information.<br>
            2. When you change the GMFHS data stored in RODM while GMFHS is active,<br>
            you might get unpredictable results until the appropriate GMFHS CONFIG<br>
            command is issued and completes.<br>
            The three GMFHS CONFIG command types are: DOMAIN, NETWORK and VIEW.<br>
             The following sections list which GMFHS CONFIG command to issue based on the<br>
            field and class you are changing:<br>
            <b>DOMAIN</b><br>
            Used when the changes include changing the association of<br>
            GMFHS_Managed_Real_Objects_Class objects with<br>
            Non_SNA_Domain_Class objects, but do not include changes that require<br>
            that the GMFHS CONFIG NETWORK command be used. See the NetView<br>
            online help for details on the behavior of the CONFIG DOMAIN<br>
            command.<br>
            <b>NETWORK</b><br>
            Used only when the changes being made include changes to information<br>
            that describes the characteristics and structure of the NMGs and domains.<br>
            <b>VIEW</b><br>
             Not needed, has been left in only for migration purposes.<br><br>
            The GMFHS CONFIG command also has a LOAD parameter. If the default<br>
            LOAD=NO is specified with CONFIG VIEW, no operation is performed. For<br>
            CONFIG DOMAIN and NETWORK, if the default LOAD=NO is specified, all<br>
            command processing is completed except for the invocation of the RODM load<br>
            function. For example, if the contents of the cache are changed by running the<br>
            RODM load function by job posting or by some RODM application other than<br>
            GMFHS, use the GMFHS CONFIG command with LOAD=NO specified. This<br>
            causes the processing within GMFHS, required for the changes, to be completed.<br><br>
            If LOAD=YES is specified, the RODM load function is run as part of the command<br>
            processing. If the INDD=ddname the data set or sets identified by ddname will be<br>
            passed to the RODM load function as the input. If the INDD parameter is not<br>
            specified the default is EKGIN3.<br><br>
            <b>Note:</b> Use the GMFHS CONFIG command with caution. This command can<br>
            reinitialize some RODM objects that are under one or more non-SNA domains.<br>
            This can result in significant CPU utilization depending on the number of real<br>
            objects that are defined. The amount of CPU utilization can be similar to the<br>
            amount used when GMFHS was initially started.<br><br>
            See the NetView online help for more information about the GMFHS CONFIG<br>
            command.<br>
            </p>
            <h3 class="A"><b>Selecting the Required GMFHS CONFIG Command</b></h3>
            <p>The following tables show which GMFHS CONFIG command is required when<br>
                objects in the RODM cache have their field values changed. To determine what<br>
                CONFIG command must be used, use the first of the following rules that applies: <br>
                <li><ul>If any object field change being made requires a CONFIG NETWORK command,<br>
                use that command.</ul></li>
                </p><br><br><br>
                <hr><hr>
                <br><br>
                <li><ul>If any object field change requires a CONFIG DOMAIN command, use that<br>
                command.</ul></li><br>
                <li><ul>Finally, if the field is not listed, no CONFIG command is required for any of the<br>
                object additions or deletions or object field value changes being made.<br>
                 However, issue the RODM CHKPT command after the completion of the RODM load<br>
                function job. This causes a new checkpoint image of the RODM cache to be<br>
                written so that it is available for cache recovery if needed.</ul></li><br>
    <p>There is no separate table provided for the addition or deletion of the objects<br>
        themselves. This is because, with the exception of SNA Domain objects, a new<br>
        object has no effect until it is linked to another object, and an object cannot be<br>
        deleted until all of its links to other objects have been deleted. The establishment<br>
        and deletion of object links is done by changing field values for fields with data<br>
        type OBJECTLINK or OBJECTLINKLIST. Changes to fields of these types are<br>
        covered by the tables.</p><br> 
        <h3 class="A"><b>Non_SNA_Domain_Class Changes</b></h3>
        <p>Table 3 shows which GMFHS CONFIG command to use when changing a field of<br>
            an object in the Non_SNA_Domain_Class.<br>
            <i>Table 3. GMFHS CONFIG Command for Non_SNA_Domain_Class Objects</i></p><br>

    <table border="1"cellpadding="1"cellspacing="1">
        <tr><td><b>Field</b></td><td><b>GMFHS CONFIG Command</b></td></tr>
        <tr><td>AlertProc</td><td>NETWORK</td></tr>
        <tr><td>CommandTimeoutInterval</td><td>NETWORK</td></tr>
        <tr><td>ContainsResource</td><td>NETWORK, DOMAIN (see note)</td></tr>
        <tr><td>DomainCharacteristics</td><td>NETWORK</td></tr>
        <tr><td>DomainCharacteristics2</td><td>NETWORK</td></tr>
        <tr><td>EMDomain</td><td>NETWORK</td></tr>
        <tr><td>InitialResourceStatus</td><td>NETWORK</td></tr>
        <tr><td>PresentationProtocolName</td><td>NETWORK</td></tr>
        <tr><td>ReportsToAgent </td><td>NETWORK</td></tr>
        <tr><td>SessionProtocolName</td><td>NETWORK</td></tr>
        <tr><td>TransactionProgram</td><td>NETWORK</td></tr>
        <tr><td>WindowSize</td><td>NETWORK</td></tr>
    </table><br>
    <p><b>Note:</b> The ContainsResource field of Non_SNA_Domain_Class objects can specify either<br>
        GMFHS-managed real resources or GMFHS-NMG objects that belong to the domain. If the<br>
        Resources field of the non-SNA Domain object is linked to the Domain field of a<br>
        GMFHS-NMG object, use the CONFIG NETWORK command. If only GMFHS-managed real<br>
         resources are being linked to or unlinked from non-SNA domain objects, the CONFIG<br>
        DOMAIN command can be used. See the NetView online help for a complete description of<br>
        the CONFIG DOMAIN command before you use it.<br>
        <h3 class="A"><b>SNA_Domain_Class Changes</b></h3><br>
        Table 4 shows which GMFHS CONFIG command to use when changing a field of<br>
        an object in the SNA_Domain_Class. Issue the GMFHS CONFIG NETWORK<br>
        command when you create or delete an object of the SNA_Domain_Class.<br>
        <i>Table 4. GMFHS CONFIG Command for SNA_Domain_Class Objects</i></p><br>
        <table border="1"cellpadding="1"cellspacing="1">
            <tr><td><b>Field</b></td><td><b>GMFHS CONFIG Command</b></td></tr>
             <tr><td>ContainsResource</td><td>NETWORK</td></tr>
    </table><br><br>
    <hr><hr>

    <i>Table 4. GMFHS CONFIG Command for SNA_Domain_Class Objects (continued)</i><br><br>
    <table border="1"cellpadding="1"cellspacing="2">
        <tr><td><b>Field</b></td><td><b>GMFHS CONFIG Command</b></td></tr>
         <tr><td>SNANet</td><td>NETWORK</td></tr>
</table><br>
<h3 class="A"><b>NMG_Class Changes</b></h3>
<p>Table 5 shows which GMFHS CONFIG command to use when changing a field of<br>
    an object in the NMG_Class.<br>
    <i>Table 5. GMFHS CONFIG Command for NMG_Class Objects</i></p>
    <table border="1"cellpadding="1"cellspacing="1">
        <tr><td><b>Field</b></td><td><b>GMFHS CONFIG Command</b></td></tr>

            <tr><td>AgentStatusEffect</td><td>NETWORK</td></tr>
            <tr><td>CommandRouteLUName</td><td>NETWORK, DOMAIN (see note)</td></tr>
            <tr><td>Domain</td><td>NETWORK</td></tr>
            <tr><td>NMGCharacteristics</td><td>NETWORK</td></tr>
            <tr><td>ReportsOnDomain</td><td>NETWORK</td></tr>
            <tr><td>TransportProtocolName</td><td>NETWORK</td></tr>
            <tr><td>WindowSize</td><td>NETWORK</td></tr>
        </table><br>
        <h3 class="A"><b>GMFHS_Managed_Real_Objects_Class Changes</b></h3>
<p>
    Table 6 shows which GMFHS CONFIG command to use when changing a field of<br>
    an object in the GMFHS_Managed_Real_Objects_Class.<br>
    <i>Table 6. GMFHS CONFIG Command for GMFHS_Managed_Real_Objects_Class Objects</i></p><br>
    <table border="1"cellpadding="1"cellspacing="2">
        <tr><td><b>Field</b></td><td><b>GMFHS CONFIG Command</b></td></tr>
         <tr><td>Domain</td><td>DOMAIN (see note)</td></tr>
    </table><br>
    <p><b>Note:</b>: If only GMFHS-managed real resources are being linked to or unlinked from<br>
        non-SNA domain objects, the CONFIG DOMAIN command can be used. See the NetView<br>
        online help for a complete description of the CONFIG DOMAIN command before you use<br>
        it.<br>
        </p><br>
        <h3 class="A"><b>Adding NMGs and Domains When GMFHS Is Active</b></h3>
        <p>NMGs and non-SNA domains can be added to RODM while GMFHS is running<br>
            without using the GMFHS CONFIG command. Use the following guidelines when<br>
            defining the objects in RODM.<br>
             <li><ul>Set the appropriate bit to indicate that you want to dynamically add an NMG or<br>
            non-SNA domain.</ul></li><br>
            <li><ul>Set the appropriate bit in the DomainCharacteristics field to indicate that you do<br>
            not want GMFHS to apply initial or unknown status to resources under a<br>
            non-SNA domain.</ul></li><br>
            <b>Note:</b> This only applies when GMFHS initially processes the NMG or non-SNA<br>
            domain. GMFHS applies initial and unknown status normally for all subsequent<br>
            processing. <br>
            <li><ul>If you do not want GMFHS to solicit resource status for a non-SNA domain, set<br>
            the appropriate bit in the DomainCharacteristics field.</ul></li><br>
            <li><ul>Link an NMG to a non-SNA domain after the NMG and domain have been<br>
            defined in RODM. GMFHS uses this link as a signal to start processing a new<br>
            NMG or domain.</ul></li><br>
            </p><br><br><br>
            <hr><hr>
            <br><br><br>
            <hr style="height: 1px; color: black; background-color: black;"><br><br>
            <h3 class="A"><b>Chapter 4. Communicating with Network Management<br>
                        Gateways</b></h3><br>
            <p>This section describes how GMFHS communicates with network management<br>
                gateways (NMGs). The NMGs send status information about non-SNA networks to<br>
                GMFHS. GMFHS sends commands for the non-SNA networks to the NMGs.<br>
                Non-SNA resources are associated with a non-SNA domain in GMFHS. When you<br>
                define non-SNA domains to GMFHS, you specify the NMG that owns each<br>
                non-SNA domain and its associated resources. You also specify how GMFHS<br>
                communicates with the NMG.<br>
                The clock on the workstation on which the NMG is running needs to be<br>
                synchronized with the clock on which the host GMFHS is running. The DOMP010<br>
                presentation protocol synchronizes these clocks. For other presentation protocols,<br>
                create your own routine to synchronize the clocks.<br>
                Refer to the Service Point Application Router and Remote Operations Service Guide for<br>
                information about using the ROP services. If the clocks are not synchronized,<br>
                GMFHS might not process alerts correctly.<br>
                 Use the information provided here to select the correct values for the following<br>
                GMFHS fields:
                <li><ul>PresentationProtocolName</ul></li>
                <li><ul>SessionProtocolName</ul></li>
                <li><ul>TransportProtocolName</ul></li><br>
                Also use the information to select the correct values for some of the bits of the<br>
                DomainCharacteristics field.<br>
                This section describes what GMFHS expects from an NMG. You need this<br>
                information to create your own service points or NMGs.<br>
                Table 7 shows the values for the three GMFHS protocol fields for typical NMGs.<br>
                <i>Table 7. GMFHS Protocol Values for Typical NMGs</i></p><br>

                <table border="1" cellpadding="1" cellspacing="1">
                    <tr><td><b>NMG name</b></td><td><b>Presentation<br>
                        ProtocolName</b></td><td><b>Session<br>
                            ProtocolName</b></td><td><b>Transport<br>
                                ProtocolName</b></td></tr>
                    <tr><td>NAP</td><td>DOMP010</td><td>DOMS010</td><td>COS</td></tr>
                    <tr><td>NetView OST1</td><td>DOMP020</td><td>PASSTHRU</td><td>OST</td></tr>
                   <tr><td>NetView OST</td><td>PASSTHRU</td><td>PASSTHRU</td><td>OST</td></tr>
                    <tr><td>NetView PPI</td><td> NONE</td><td> NONE</td><td>PPI</td></tr>
                    <tr><td>Open Topology<br>
                        Interface Agent2</td><td>DOMP010</td><td> NONE</td><td>COS</td></tr>
                        <tr><td>PPI</td><td>DOMP020</td><td>PASSTHRU</td><td>PPI</td></tr></table><br>
                        <p>1 Use the DOMP020 presentation protocol if you want to use parameter substitution.<br>
                             2 IBM Tivoli NetView for z/OS Open Topology Interface Agent.</p><br>
                             <br><br><br><br>
                             <hr><hr>
                             <p>Remember that this table lists typical values for the protocol parameters. Other<br>
                                combinations of parameter values are possible and the values you use depend on<br>
                                what your NMGs support.</p>
           <hr style="height: 1px; color: black; background-color: black;">
           <h3 class="A"><b>Defining Non-SNA Presentation Protocol</b></h3>
           <p>The presentation protocol translates commands to and from the syntax used by the<br>
            element management system. The translation is done according to the rules for the<br>
            domain associated with the resource that is the target of the command.<br>
            The PresentationProtocolName field of the Non_SNA_Domain_Class object<br>
            specifies which protocol is used for the non-SNA domain. The valid protocol<br>
            names are: 
            <li><ul>DOMP010</ul></li> 
            <li><ul>DOMP020</ul></li> 
            <li><ul>PASSTHRU</ul></li> 
            <li><ul>NONE</ul></li> 
        </p>
        <p><h3><b>DOMP010 Presentation Protocol</b></h3>
            &nbsp;&nbsp;&nbsp;&nbsp;The DOMP010 protocol enables generic commands to be translated for delivery to<br>
            the gateway associated with the domain and also enables the responses to<br>
            commands formatted using the DOMP010 protocol to be translated to<br>
            DisplayStatus. The DisplayStatus is reflected in the appearance of objects in the<br>
            views. Native and resource-specific commands can also be delivered using the<br>
            DOMP010 protocol supported by the native-element manager or transaction<br>
            program associated with the domain.<br>
            The DOMP010 presentation protocol specifies that the command messages and<br>
            command response messages from the NMG are formatted according to the rules<br>
            described in “DOMP010 Formatting Rules” on page 63.<br>
            The DOMP010 protocol provides translation of the following types of commands:<br>
             <li><ul>Generic commands:</ul></li>
            – Activate<br>
            – Display Abnormal Status<br>
            – Display Status <br>
            – Inactivate <br>
            – Reconfigure <br>
            – Recycle<br>
            <li><ul>Session protocol commands</ul></li><br>
            <li><ul>Native and resource-specific command text</ul></li><br>
            The DOMP010 protocol also provides for the translation of command responses<br>
            from native element managers for any command.<br>
            For native commands, DOMP010 performs parameter substitution on the<br>
            command entered by the operator. GMHFS replaces the tokens in the command as<br>
            follows:<br>
            <b>Token Action taken by GMFHS</b><br>
        <b>%APPL%</b><br>
            &nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the TransactionProgram field of the<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Non_SNA_Domain_Class object.<br>
            </p>
            <br><br><br>
            <hr><hr>
            <b>%DOMAIN%</b><br>
            &nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the EMDomain field of the<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Non_SNA_Domain_Class object.<br>
<b>%RESOURCE%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the MyName field of the resource.<br>
<b>%SPNAME%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the MyName field of the NMG_Class object.<br>
<b>%TYPE%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the TypeName field of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;Display_Resource_Type_Class object associated with the resource.<br>
GMFHS accepts the following parameters in native OST text:<br>
 <li><ul> %RESPONSE%</ul></li>
 <li><ul>%NORESPONSE%</ul></li>
The %RESPONSE% parameter forces all valid command responses to be returned<br>
to the workstation. The %RESPONSE% parameter overrides the Response Expected<br>
bit of the Non_SNA_Domain_Class DomainCharacteristics field. The<br>
%NORESPONSE% parameter forces the native command to be issued at the OST<br>
console, and no response is returned to the workstation.<br><br>
The DOMP010 presentation protocol is applicable only on COS and<br>
program-to-program interface NMGs.<br><br>
<h3 class="A"><b>DOMP020 Presentation Protocol</b></h3>


The DOMP020 protocol enables generic commands to be translated for delivery to<br>
the NMG associated with the domain. The DOMP020 protocol supports native and<br>
resource-specific command text. Responses to these commands are returned<br>
unchanged to the command response window of the originating workstation.<br>
GMFHS does not extract status information from these responses.<br>
The text of generic commands is retrieved from RODM. GMFHS requests the<br>
command text from the GMFHS_Managed_Real_Objects_Class object that<br>
represents the target of the command. If this object does not define the command<br>
text, GMFHS then requests the command text from the Non_SNA_Domain_Class<br>
object that represents the domain of the command's target. The Display Abnormal<br>
Status and Reconfigure generic commands are valid only if the target of the<br>
command is an object of the Non_SNA_Domain_Class. The fields used for generic<br>
commands follow:<br>
<b>Generic Command</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>GMFHS Field</b><br>
<b>Activate</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;ActivateCommandText<br>
<b>Deactivate</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;DeactivateCommandText<br>
<b>Display Abnormal Status</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;DisplayAbnormalStatusCommandText<br>
<b>Display Status</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;DisplayStatusCommandText<br>
<b>Reconfigure</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;ReconfigureCommandText<br>
<br><br>
<hr><hr>
<b>Recycle</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;RecycleCommandText<br>
When GMFHS locates the command, it performs parameter substitution. GMFHS<br>
looks for any of the following tokens in the command, and replaces them as<br>
follows:<br>
Token &nbsp;&nbsp;Action taken by GMFHS<br>
<b>%APPL%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the TransactionProgram field of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;Non_SNA_Domain_Class object.<br>
<b>%DOMAIN%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the EMDomain field of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;Non_SNA_Domain_Class object.<br>
<b>%RESOURCE%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the MyName field of the resource.<br>
<b>%SPNAME%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the MyName field of the NMG_Class object.<br>
<b>%TYPE%</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;Replace with the value of the TypeName field of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;Display_Resource_Type_Class object associated with the resource.<br>
<b>Note:</b>Display Abnormal Status and Reconfigure commands pertain only to<br>
domains; therefore only the domain object is searched for the command text.<br>
The DOMP020 protocol is used with all NMG types. The gateways allow<br>
commands to be delivered to the OST associated with a workstation operator or to<br>
the central site NetView primary program operator interface task (PPT) if the<br>
command is from GMFHS. The command procedure or processor that is run for<br>
the command might directly or indirectly generate an alert. The alert reports the<br>
resulting resource status.<br>

<h3><b>PASSTHRU Presentation Protocol</b></h3>
The PASSTHRU protocol specifies that native network command text entered by a<br>
workstation operator passes directly to the native element management system<br>
unchanged, and that native network command response text returns to the<br>
workstation operator without interpretation by GMFHS.<br>
The PASSTHRU presentation protocol specifies that the actual text of the<br>
commands is retrieved from RODM. The differences between PASSTHRU and<br>
DOMP020 are that PASSTHRU does not support generic commands and does not<br>
perform parameter substitution.<br>
<h3><b>NONE Presentation Protocol</b></h3>
Specify NONE for the PresentationProtocolName value for a domain if commands<br>
are not sent to the NMG associated with the domain. For example, specify NONE<br>
when domains are defined to only receive alerts for the resources they contain.<br>
<h3><b>Output Formatting For All Presentation Protocols</b></h3>
This section describes output formatting for the DOMP020 and PASSTHRU<br>
protocols and for the DOMP010 protocol.<br><br>

<h4><b>DOMP020 and PASSTHRU Output Formatting</b></h4>
    If the NMG is using the COS transport protocol, the subvector 31 contains the<br>
    response to a RUNCMD. The response in subvector 31 is formatted as follows:<br>
    when the native element manager sends multiple lines of response text to GMFHS,<br>
    each line of response text must be put in a separate subvector 31. This ensures that<br>
    each separate line of response text is displayed in the workstation Command<br>
    Responses window as a separate line of text.<br>
    <h4><b>DOMP010 Output Formatting</b></h4>
    Each separate line of text in a multiple line response is preceded by a separate text<br>
    keyword (TX). See “Text—TX” on page 70 for more information about the use of<br>
    the TX keyword for the DOMP010 protocol.<br>
    <h3 class="A"><b>DOMP010 Formatting Rules</b></h3>
    This section describes the format of the textual data contained in either the<br>
    commands for COS NMGs or the data delivered to program-to-program interface<br>
    NMGs. In this section, the term packet refers to the information in these subvectors.<br>
    <b>General Packet Format</b><br>
    A packet is made up of one or more comma-delimited keyword parameters. These<br>
    parameters perform such functions as identifying the command or response. All<br>
    values in the text packet are displayable characters.<br>
    <li><ul> In the NetView/PC API/CS environment, the displayable characters are coded<br>
    in ASCII. </ul></li><br>
    <li><ul>In the SNA network, the characters are coded in displayable EBCDIC.<br>
    NetView/PC API/CS performs the necessary code set translations.</ul></li><br>
    Each parameter has the following general format:<br>
    keyword=value<br><br>
    Each keyword is 2 - characters long, and the equal sign is always present. The<br>
    value is of variable length. For example, if CP is a keyword that has the value<br>
    MINIA, the keyword parameter is:<br>
    CP=MINIA<br>
    Keyword values can be made up of more than one data item, delimited with<br>
    commas and surrounded by one set of parentheses, for example:<br>
    CP=(MINIA,MINIB)<br><br>
    In a typical packet, several keyword parameters are specified. The keyword<br>
    parameters are also delimited by commas, for example:<br>
    CM=AE,SQ=10,DM=DOMAIN,CP=(MINIA,MINIB)<br>
RP=AE,SQ=10,DM=DOMAIN,<br>
CP=MINIA,ST=U,TM=930601120000,<br>
CP=MINIB,ST=U,TM=930601120000,<br>
In most cases, the order of the individual parameters is unimportant. Exceptions to<br>
this rule are noted in the descriptions of the keywords.<br>
Keyword and Value Definitions<br>
The packet keywords and their descriptions follow:<br>
<b>Keyword</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Description</b><br>
<b>CE</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Command execution<br><br><br>
    </p>
    <hr><hr>
    <br><br>
<b>CM</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Command identifier, required for commands<br>
<b>CP</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component identifier<br>
<b>DM</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Domain identifier<br>
<b>PT</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Protocol text<br>
<b>RN</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reason<br>
<b>RP</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Response identifier, required for responses<br>
<b>SN</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Command sender identifier<br>
<b>SQ</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message sequence number, required for commands and responses<br>
<b>ST</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Status identifier<br>
<b>TM</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time stamp<br>
<b>TX</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Native command or response text<br>
<br>
<p>The following sections describe each keyword and its values.</p>
<h4><b>Command Execution—CE</b></h4>
The command execution status keyword (CE) indicates a failure to successfully run<br>
a command. It differs from a negative response (RP=X) in that the negative<br>
response applies to the entire command. A command execution failure applies to a<br>
subset of the command.<br>
The keyword values for CE are value lists contained in a text string. The values are<br>
the same as those for the reason (RN) keyword. See “Reason-RN” on page 67 for<br>
these values.<br>
When the command is Display Status (CM=D) or Display Abnormal Status<br>
(CM=A), and the statuses of more than one component are carried in the response,<br>
a command execution failed for any one of the components. This is indicated by<br>
the following:<br><br>
<i>CP=component_name,ST=X,<br>
CE=(reason text)</i><br><br>
The same command response carries the status of those components for which the<br>
command was successful. If command execution fails for each component<br>
individually, the CE keyword and ST=X are returned for each component.<br>
Note: The use of ST=X, is required, and indicates that any status already reported<br>
for this component is still in effect.<br>
The CE keyword is position dependent. CE must follow the CP keyword for its<br>
subject component, and precede any other components. That is, the CP and CE<br>
pair for a given component must not be split by another CP keyword.<br>
The CE keyword is supported for Display Status and Display Abnormal Status<br>
commands (CP=A and CP=D).<br>
<h4><b>Command—CM</b></h4>
The command keyword, CM, is the command issued to the element manager. This<br>
keyword is required on any packet sent from the host to an element manager. <br>
CM values have a two-part definition:<br><br><br><br>
<hr><hr>
<li><ul>The first byte of the value is the command type. The command type classifies<br>
the type of command you issue to the non-SNA device. The following list<br>
describes the command types.</ul></li><br>
<b>Value &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Description</b><br>
<b>A</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display abnormal status<br>
<b>C</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reconfigure domain<br>
<b>D</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display status for a named resource or resources<br>
<b>I</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inactivate resource<br>
<b>N</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Native command<br>
<b>P</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Protocol message<br>
<b>R</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recycle resource<br>
<b>V</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Activate resource<br>
<b>X</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Negative response<br>

<li><ul>The second byte is the continuation.</ul></li><br>
The continuation byte is used in conjunction with command types that can<br>
require multiple responses.<br>
<b>Value &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Description</b><br>
<b>E</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is either an initial request or the last response to an initial request.<br>
<b>M</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is either a continuation request or not the last response when<br>
multiple responses are required to service an initial request.<br>
For more information about the importance of the continuation byte, see<br>
“Multiple-Response Protocol” on page 71.<br>

<h4><b>Component ID—CP</b></h4>
The component ID provided by the CP keyword must match the resource portion<br>
of the MyName value of a GMFHS_Managed_Real_Resource object in the RODM<br>
data cache. For example, if the MyName of the resource is OTTAWA.MINIA,<br><br>

specify CP=MINIA. You can specify multiple resources with one CP keyword by using a value list. For<br>
example, if three resources are included in one command, the CP keyword is:<br>
CP=(MINIA,MINIB,MINIC)<br><br>
<b>Note:</b> Command responses use multiple CP values, rather than a component ID<br>
list, if the response is for multiple resources.<br>
The size of the CP keyword value depends on the following: <br>
<li><ul> The type of NMG containing the element manager</ul></li>
<li><ul>The size of required keywords in the command</ul></li>
<li><ul>The size of optional keywords in the command</ul></li>
The maximum command size depends on the NMG type. The maximum size can<br>
be one of the following: <br><br>
<li><ul>240 characters for the COS gateway</ul></li>
<li><ul> 256 characters for OST gateways</ul></li>
<li><ul>253 characters for program-to-program interface gateways</ul></li><br><br>
To determine the valid maximum size of the resource names in the CP keyword,<br>
do the following:<br>
1. Add the number of characters in the base command and the number of<br>
characters in the CP keyword syntax.<br>
2. Subtract that total from the maximum length that the NMG supports.<br>
<br><br><br><br><br>
<hr><hr>
For example, the following command contains 24 characters:<br>
CM=DE,SQ=5,DM=DOMAIN,CP=aaa<br><br>
Therefore, the maximum size of the resource name aaa is 216 characters for the<br>
COS gateway, 232 characters for OST gateways, and 229 characters for<br>
program-to-program interface gateways.<br><br>
The following command contains 28 characters:<br>
CM=DE,SQ=5,DM=DOMAIN,<br>
CP=(aaa,bbb,ccc)<br><br>
Therefore, the maximum size of the resource names aaa, bbb, and ccc is 212<br>
characters for the COS gateway, 228 characters for OST gateways, and 225<br>
characters for program-to-program interface gateways.<br><br>
If you specify multiple components in the command and the size of the command<br>
exceeds the maximum, GMFHS automatically reduces the number of resources in<br>
the command to reduce the command size.<br><br>

<h4><b>Domain—DM</b></h4>
The domain keyword, DM, specifies the non-SNA domain of a resource when<br>
multiple non-SNA domains are supported. The domain keyword is optional.<br><br>
DM signifies the domain in which the GMFHS associates a resource specified with<br>
the CP keyword. DM needs to match the EMDomain field of the<br>
Non_SNA_Domain_Class object. For example, if the MyName of the resource is<br>
OTTAWA.MINIA, the keyword parameter format is:<br>
DM=OTTAWA<br><br>
The DM value can be up to 8 characters in length.<br><br>
<h4><b>Protocol-PT</b></h4>
The protocol keyword, PT, is used when a command identifier (CM) or response<br>
identifier (RP) command type equals protocol command (P); for example, CM=PE<br>
(E is the continuation byte).<br><br>
The PT values are protocol commands that control the communication session<br>
between two cooperating processes: on the host, and on the target of the command<br>
(the native element manager). Because all commands require responses, any<br>
protocol command request must have a protocol-type response.<br><br>
Table 8 lists the defined PT values and displays the session protocol commands<br>
used for the DOMS010 protocol.<br>
<i>Table 8. Protocol Command Values</i><br><br>
<table border="1"cellpadding="1"cellspacing="1">
    <tr><td><b>Protocol Command</b></td><td><b>Meaning</b></td></tr>
     <tr><td>SESSION_REQUEST</td><td>Sent by GMFHS to the element manager to request that a<br>
        session be established.</td></tr>
     <tr><td>SESSION_REQUEST_ACCEPT</td><td>A response acknowledging a SESSION_REQUEST protocol<br>
        command. This command does not indicate that a session is<br>
        established.</td></tr>
     <tr><td>INIT_ACCEPT</td><td>Returned by GMFHS to acknowledge receipt of the INIT<br>
        alert</td></tr>
     <tr><td>INIT_ACCEPT_ACCEPT</td><td>A response acknowledging the INIT_ACCEPT protocol<br>
        command.</td></tr>
    </table><br><br><br><br>

<hr><hr>

<i>Table 8. Protocol Command Values (continued)</i>
<table border="1"cellpadding="1"cellspacing="1">
    <tr><td><b>Protocol Command</b></td><td><b>Meaning</b></td></tr>
     <tr><td>SET_CLOCK</td><td>Sent by GMFHS after it receives the<br>
        INIT_ACCEPT_ACCEPT protocol command and if the<br>
        SET_CLOCK protocol command is supported by the<br>
        domain's native element manager. This message is sent only<br>
        if the support set clock bit is set to "on" in the<br>
        DomainCharacteristics field.<br>
        SET_CLOCK provides the current local time in its TM<br>
        parameter value. This message is issued every 24 hours for<br>
        as long as the session remains active.<br>
        </td></tr>
     <tr><td>SET_CLOCK_ACCEPT</td><td>Returned by the native element manager to acknowledge<br>
        the SET_CLOCK protocol command.</td></tr><br>
</table>

<b>Note:</b> The values for the PT keyword in commands coming from GMFHS are lowercase.<br>
 GMFHS is not case-sensitive on the response values.<br>
For example, if the GMFHS is responding to an INIT alert from the NMG, the<br>
format of the packet is:<br><br>
CM=PE,DM=DURHAM,SQ=7,PT=(INIT_ACCEPT)<br>
The response to the INIT_ACCEPT is:<br>
RP=PE,DM=DURHAM,SQ=7,PT=(INIT_ACCEPT_ACCEPT)<br><br>
If the SET_CLOCK protocol command is supported, GMFHS sends it to the NMG<br>
every 24 hours, allowing the NMG to set its clock to the correct time. The current<br>
time is carried by the TM keyword and accounts for the NMG's offset specified in<br>
the INIT alert. For example:<br><br>
CM=PE,SQ=8,DM=DURHAM,PT=(SET_CLOCK),TM=930101120000<br>
RP=PE,SQ=8,DM=DURHAM,PT=(SET_CLOCK_ACCEPT)<br><br>
See “Session Establishment for DOMS010” on page 74 for more information about<br>
these protocols.<br><br>
<h4><b>Reason-RN</b></h4>
The reason keyword (RN) indicates why a request was not honored. RP=XE is<br>
always used with the RN keyword.<br>
The reason value is a text string in value list format. For example:<br>
RN=(execution node inaccessible)<br><br>
Table 9 lists the supported text values.<br>
<i>Table 9. Reason Values</i>

<table border="1"cellpadding="1"cellspacing="1">
    <tr><td><b>Value</b></td><td><b>Description</b></td></tr>
     <tr><td>Aborted</td><td>An error occurred prohibiting the completion of a request<br>
        (failure in memory, CPU, disk, and so on).</td></tr>
     <tr><td>Canceled</td><td>The request was canceled before it can be completed.</td></tr>
     <tr><td>Component unknown</td><td>The target component is unknown</td></tr>
     <tr><td>Currently not allowed</td><td>The command type is supported but cannot be run by the<br>
        target component at this time.</td></tr>
        <tr><td>Execution node inaccessible</td><td>The target node that runs the requested command is not<br>
            accessible.
</table><br><br>
<hr><hr>

<i>Table 9. Reason Values (continued)</i>
<br>
<table border="1"cellpadding="1"cellspacing="1">
    <tr><td><b>Value</b></td><td><b>Description</b></td></tr>
     <tr><td>Failed</td><td>The command processing completed, but failed to achieve
        the expected results (ACTIVATE did not result in the
        component becoming active).
        </td></tr>
     <tr><td>Inavlid Command ID</td><td>The command type is not valid.</td></tr>
     <tr><td>Invalid Paramters</td><td>A keyword parameter was incorrect and prohibited the
        execution of the command.</td></tr>
     <tr><td>No Resources</td><td>There were insufficient resources available to run the request
        (memory, CPU, disk, and so on).</td></tr>
        <tr>Not Allowed<td></td><td>The command type is supported but is not allowed for the
            target component.</td></tr>
        <tr><td>Not supported</td><td>The command type is not supported by the entity
            processing the command.</td></tr>
        <tr><td>Preempted</td><td>The request was preempted by another process before it can
            be completed.</td></tr>
        <tr><td>TimedOut</td><td>The request timed out before a valid response can be
            processed.</td></tr>
</table><br><br>

<b>Note: </b>GMFHS is not case-sensitive on the response values.<br>
<h4><b>Response—RP</b></h4>
The response keyword, RP, identifies a command response packet. The response<br>
keyword values are the same as described for the command keyword, CM, under<br>
“Command—CM” on page 64. RP values also use the continuation byte as<br>
described in the CM values.<br><br>
For example, if you issue a Display Status command for a single component, the<br>
response is positive and no continuation message is required. The format of the<br>
keyword parameter is:<br><br>
RP=DE,SQ=5,DM=DOMAIN,CP=MINIA<br>
If the response to a request is negative (request cannot be successfully completed),
an X is placed in the first byte for the command type. For example:<br>
RP=XE,SQ=5,DM=DOMAIN,RN=(no resources)<br><br>
<h4><b>Command Sender ID—SN</b></h4>
The command sender ID keyword, SN, identifies the sender of the command. The<br>
SN keyword is included in all commands. The keyword value is always GMFHS:<br>
SN=GMFHS<br><br>
<h4><b>Message Sequence Number—SQ</b></h4>
The message sequence number keyword, SQ, contains a unique message sequence<br>
number that identifies either the request or response. The message sequence<br>
number of a response is identical to the sequence number used in the original<br>
request. For example, if you issue a Display Status command for one component<br>
with a sequence number of 6, the response to that request also has a sequence<br>
number of 6.<br><br>
SQ provides a correlation for the continuation responses. If a single request<br>
requires multiple responses, the message sequence number is used to correlate all<br>
of the responses to the original request. For example, if you issue a Display<br>
Abnormal Status COMPONENTS command with a message sequence number of<br>


<hr><hr>
<p>35, the first response in a series of responses has a message sequence number of 35<br>
    and the continuation byte set to more (M). For example:<br>
    CM=AM,SQ=35<br><br>
    The originator can send another request with the continuation byte set to M and a<br>
    message sequence number of 35. When the responder receives this request, it<br>
    knows to continue sending the data that does not fit in the previous response<br>
    packet. This multiple exchange continues until the original request is satisfied with<br>
    the continuation byte in the response being set to end (E).<br>
    Message sequence numbers roll over after reaching 999.<br>
    <h4><b>Status—ST</b></h4>
    The status keyword, ST, can be used to describe either of the following:<br>
     <li><ul>The status of a component in response to a display status (CM=A or CM=D)<br>
    command</ul></li><br>
    <li><ul>The resulting component status in response to an activate (CM=V), deactivate<br>
    (CM=I), or recycle (CM=R) command<br></ul></li>
    The value for a status keyword can be the GMFHS external status of the resource,<br>
    which is a 1-byte value.<br>
    Only one status value type is enabled for any given resource in a response<br>
    message.<br>
    When status is reported on multiple resources, the ST keyword parameter and<br>
    value must immediately follow each associated component ID keyword (CP). If the<br>
    ST and TM keywords are sent together, their specific order does not matter, as long<br>
    as they both follow the associated CP keyword.<br><br>
    If the GMFHS external status of a resource is unsatisfactory, the format of the ST<br>
    keyword parameter is:<br>
    ST=U<br><br>
    If the GMFHS external statuses of components NODE1 and NODE2 are being<br>
    reported, and their respective statuses are satisfactory and unsatisfactory, the<br>
    format of the ST keyword parameter is as follows:<br><br>
    CP=NODE1,ST=S,TM=890315120801,CP=NODE2,ST=U,TM=890315120814<br>
    <h4><b></b></h4>Time Stamp—TM
    The time-stamp keyword, TM, describes the local date and time. The TM value<br>
    and keyword are required whenever a command response provides a component,<br>
    and for each component status provided in the response.
    This includes D, A, I,<br> V, and R commands. The time-stamp keyword can be in other responses but is<br>
    ignored. The TM keyword is also included on a SET_CLOCK session protocol<br>
    command to specify the element manager's clock setting.<br>
    When time is reported on multiple resources, the TM keyword parameter and<br>
    value must immediately follow each associated component ID keyword (CP). If the<br>
    TM and ST keywords are sent together, their specific order does not matter, as long<br>
    as they both follow the associated CP keyword. The format of the time stamp is:<br>
    <i>TM=yymmddhhmmss</i></p><br><br>

    The time stamp variables are defined as:
    <b>yy</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Year<br>
    <br><br><br>
    <hr><hr>
    <br><br>
    <b>mm</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;month (01 - 12)<br>
    <b>dd</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;day (01-31)<br>
    <b>hh</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hour (00 - 23)<br>
    <b>mm</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minute (00-59)<br>
    <b>ss</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second (00-59)<br>
    <br>
    <p>For example, if a status is being reported as of 3:58:21 p.m. local time on 28 May,<br>
         2013, the TM keyword parameter is:<br>
        <i>TM=130528155821</i><br>
        <h4><b>Text—TX</b></h4>
        The text keyword, TX, provides support for native commands and their responses.<br>
        The value for TX is a string of text.<br>
        For commands, the TX value is the text of a native network command, such as a<br>
        command entered at the native element manager's console. The following is the<br>
        data item format for the SHOW CIRCUIT A native command:<br>
    <i>TX=(SHOW CIRCUIT A)</i><br>
        For responses, TX is the response text received at the native element manager's<br>
        console. Command responses are shown in the Command Response window, if the<br>
        command was issued by the operator. Each occurrence of the TX keyword results<br>
        in one line of text displayed at the NetView workstation. The following is the<br>
        format of the response keyword parameter, if the response to the command is<br><br>
        CIRCUIT A CONFIGURED AND OPERATIONAL:<br>
    <i>TX=(CIRCUIT A CONFIGURED AND OPERATIONAL)</i><br><br>
        If the response to the command is a multiple line response, the format of the<br>
        response keyword parameters is:</p><br><br>

    <i>TX=( COMMAND FAILURE STATISTICS),<br>
TX=(ROUTES ERRORS HITS MISSES),<br>
TX=( 40 250 2000 4)</i><br><br>
Commas separate the individual parameter lines. In the case of text responses, the<br>
order of the parameter lines is important, and each separate TX keyword results in<br>
a separate line of text in the Command Response window.<br>
 A ) character (right parenthesis) ends the TX text string. If the text includes an<br>
imbedded ) character, precede the ) with a second ) character. The following is the<br>
format of the response keyword parameter, if the response to the command is<br><br>
CIRCUIT (A) CONFIGURED AND OPERATIONAL:<br>
<i>TX=(CIRCUIT (A)) CONFIGURED AND OPERATIONAL)</i><br>
    
<h3 class="A"><b>Command Formatting and Protocol Examples</b></h3>
This section provides examples of the required presentation processing protocol.<br>
Functionally, there are two protocols: v Single-response protocol v Multiple-response protocol<br><br>
See “Keyword and Value Definitions” on page 63 for a description of the various<br>
keywords and values that make up the command and response packets of the<br>
command. See “Command—CM” on page 64 for a list of the command types and<br>
continuation bytes.<br><br><br><br>
<hr><hr>
<h3><b>Single-Response Protocol</b></h3>
The single-response protocol consists of a command designated as an initial<br>
command and a response designated as a last response. Figure 16 shows the<br>
packets exchanged for a Display Status command and response.<br>
<img src="C:\Users\Shona\Pictures\Screenshots\Figure16.png"><br>
<p>The command, sent from GMFHS, contains the CM keyword. Maintaining the<br>
    protocol, the first character of the CM value, D, is interchangeable. It signifies the<br>
    display status command type. This value can also be any command type valid for<br>
    the command.<br><br>
    However, the E value in the continuation character specifies an initial command.<br>
    This character must always be in the first occurrence of a command packet,<br>
    regardless of whether or not additional command packet continuations
    (continuation value = M) are required.<br><br>
    In the response from the native element manager, the RP keyword has the value<br>
    DE. The command type character is interchangeable. The E value in the<br>
    continuation character specifies that the response is the last response generated.<br>
    The protocol has an additional check in the SQ keyword. The SQ value for a<br>
    response must equal the SQ value for the command.<br><br>
    As the following example shows, the single-response protocol allows for a<br>
    response containing data for more than a single resource.<br>
    The command requests the status of three resources, RALV4.RALXT1,<br>
    RALV4.RALXT2, and RALV4.TX02, in a single CP keyword parameter. <br>
<i>CM=DE,DM=EASTSIDE,CP=(RALV4.RALXT1,RALV4.RALXT2,RALV4.TX02),SQ=1</i><br>
    The response contains separate CP keywords for each requested resource.<br><br>
    <i>RP=DE,DM=EASTSIDE,CP=RALV4.RALXT1,ST=N,TM=901201135901,<br>
    CP=RALV4.RALXT2,ST=N,TM=901201135912,<br>
    CP=RALV4.TX02,ST=D,TM=901201135914,SQ=1</i><br>
    <b>Note:</b> The CM and SQ keyword parameters are in the command. RP and SQ<br>
    parameters are in the response.<br>
    <h4><b>Multiple-Response Protocol</b></h4>
    When the response data is too large to fit in a single response, GMFHS and the<br>
    NMG use the multiple-response protocol.</p><br>
<br><br><br>
    <hr><hr>
    <br><br>
    <p>The multiple-response protocol consists of: <br>
         <li><ul>A command designated as an initial command</ul></li>
         <li><ul>An unlimited number of continuation responses and commands</ul></li>
         <li><ul> A last response</ul></li>
        Figure 17 shows the packets exchanged for a Display Status command and the
        response in the simplest multiple-response case.</p>

        <img src="C:\Users\Shona\Pictures\Screenshots\Figure17.png"><br>
        <p>The initial command, sent from the NetView program, contains the CM keyword<br>
            with the continuation character set to E (CM=AE). The NMG response indicates<br>
            that the response does not contain all of the data by including the value M as the<br>
            RP keyword continuation parameter (RP=AM).<br>
            To get more of the response data, GMFHS reissues the request. All request<br>
            parameters are the same as the initial request except for the continuation<br>
            parameter, which is set to M (CM=DM). The NMG sends the remaining data and<br>
            indicates that no more data will be sent by setting the continuation parameter to E<br>
            (RP=AE).<br>
            The following initial command calls for a display of all resources in the non-SNA<br>
            domain B3088P2 that have a status of abnormal:<br><br>
            <i>CM=AE,DM=B3088P2,SQ=44</i><br>
            The following response results:<br>
            <i>RP=AM,DM=B3088P2,SQ=44,CP=TIM,ST=A,TM=911231235959,<br>
            CP=A0488P23,ST=C,TM=920101000000,<br>
            CP=A0488P24,ST=U,TM=920101000001</i><br>
            This response indicates that there is a continuation of the response (RP = AM) and<br>
            provides the statuses of three resources, A0488P22, A0488P23, and A0488P24.<br>
            The command is sent again:<br>
            <i>CM=AM,DM=B3088P2,SQ=44</i><br>
            The continuation character is set to M (CM = AM), indicating that the command is<br>
            a continuation of the previous command with sequence number 44 (SQ=44).<br>
            Finally, another response ends the exchange:<br>
            <i>RP=AE,DM=B3088P2,SQ=44,CP=RALV4.TX02,ST=A,TM=920101000002</i><br>
            The continuation character is set to E (RP=AE), indicating that this is the last<br>
            response.<br><br><br>
            <hr><hr>
            <br><br>
            <h3><b>Timing Considerations</b></h3>
               <p>Because status information is contained in both generic alerts and command<br>
                responses, GMFHS provides a time stamp at the time it processes the alert or<br>
                response. The date and time of an alert, are provided by the native element<br>
                manager or its agent in the NMG.<br>
                <h4><b>Alerts</b></h4>
                The NetView program assumes that the effective time of an alert when the alert is<br>
                received by the NetView program.<br>
                This standard presents problems for non-SNA alerts reported through an NMG.<br>
                The alert can be delayed significantly in the non-SNA network and in the NMG<br>
                before it is delivered to the VTAM program and then to GMFHS. Delays can result<br>
                in inaccurate alert time-stamping that complicates or defeats efforts at network<br>
                problem resolution. GMFHS uses the following rules to overcome these<br>
                shortcomings:<br>
                <li><ul>The alert originator can include a date/time subvector in the alert. It overrides<br>
                the time that the NetView program receives the alert. The Greenwich mean time<br>
                (GMT) offset in the subvector is used, if in the optional GMT offset subfield. <br></ul></li>
                <li><ul>If the alert date/time subvector does not include the GMT offset and the native<br>
                element manager reported its GMT offset at session establishment, the native<br>
                element manager's offset is used.<br></ul></li>
                <li><ul>If the alert date/time subvector does not include the GMT offset, and session<br>
                establishment does not provide an offset, the time in the date/time subvector is<br>
                used and normalized with the NetView program's local GMT offset.<br></ul></li>
                <h4><b>Command Responses</b></h4>
                GMFHS requires that the time-stamp keyword parameter (TM) be included in any<br>
                command response containing a component status. However, a status response can<br>
                arrive at GMFHS after a more recent alert for the same component. This happens if<br>
                the native element manager is assembling a response with statuses from multiple<br>
                components, and the status of one component changes after it is in the response,<br>
                but before the response is sent. If the native element manager sends an alert for<br>
                this component before it sends the command response, GMFHS receives the status<br>
                indications in the wrong order. GMFHS recovers from this situation by comparing time stamps. If a status update<br>
                (either an alert or a command response) is time stamped earlier than the most<br>
                recent status reported, GMFHS does not apply the new status. GMFHS logs an<br>
                audit message and a console message.<br><br>
                The time-stamp keyword does not include the GMT offset. GMFHS normalizes<br>
                time stamps to compare them. If the INIT alert used to establish the session<br>
                between GMFHS and the native element manager contains the native element<br>
                manager's GMT offset, this offset is used. Otherwise, the GMFHS local GMT offset<br>
                is used.</p>
            </p>
            <hr style="height: 1px; color: black; background-color: black;">
           <h3 class="A"><b>Defining Non-SNA Session Protocols</b></h3>
           <p>The session protocol you specify for a non-SNA domain indicates how GMFHS<br>
            establishes, maintains, and ends command and response communication sessions<br>
            for that domain. The presentation protocol used for a domain is specified in the<br>
            SessionProtocolName field of the non-SNA domain object in RODM. The valid<br>
            session protocol names are: <br>
            <li><ul>DOMS010</ul></li> <br>
            <hr><hr>
            <br><br><br>
            <li><ul>PASSTHRU</ul></li>
            <li><ul>NONE</ul></li><br>
            <p>GMFHS is also responsible for establishing, maintaining, and ending<br>
                communication sessions with the element managers. GMFHS uses the value of the<br>
                SessionProtocolName field of the Non_SNA_Domain_Class object to determine<br>
                how to establish a session with the element manager.</p><br>
            
                <h3><b>DOMS010</b></h3>
                The DOMS010 protocol specifies a set of rules and a command syntax that<br>
                coordinate the establishment of a command session between GMFHS and the<br>
                non-SNA domain.<br>
                The DOMS010 session protocol specifies that GMFHS and the element manager<br>
                must verify each other's identities before GMFHS determines that a session exists.<br><br>
                The commands GMFHS sends the element manager, and the responses it expects,<br>
                are described in “Protocol-PT” on page 66. In addition, “Session Establishment for<br>
                DOMS010” contains examples of the identification sequence.<br>
                If the domain specifies DOMS010, the commands are formatted according to the<br>
                DOMP010 formatting rules, regardless of the values in the<br>
                Presentation ProtocolName field.<br><br>
                <h3><b>PASSTHRU</b></h3>
                The PASSTHRU protocol specifies that a command session is to exist between<br>
                GMFHS and the non-SNA domain without any exchange of session establishment<br>
                information. GMFHS assumes the command session is active immediately upon<br>
                GMFHS initialization.<br><br>
                <h3><b>NONE</b></h3>
                The NONE protocol indicates that there is no command support for the domain.<br>
                Session Establishment for DOMS010<br>
                The DOMS010 session protocol stipulates that GMFHS must acquire a session with<br>
                the domain before any other commands are available. Sessions are initiated by<br>
                GMFHS, or from the element manager. Figure 18 on page 75 shows a session<br>
                establishment initiated from the element manager.<br><br>
                 To view what GMFHS is reporting as the status of a domain, use the GMFHS<br>
                SHOW DOMAIN command. Refer to NetView online help for information about<br>
                the SHOW command.<br></p>

                <br><br><br><br><br><br><br>
                <hr><hr>
                <br><br>
                <img src="C:\Users\Shona\Pictures\Screenshots\Figure18.png"><br>
                <p>The element manager can initiate a session with GMFHS by sending an INIT<br>
                    generic alert. When GMFHS receives the alert, it does the following: <br>
                <li><ul>Responds to the NMG with an INIT_ACCEPT protocol command. The INIT alert<br>
                    is described in “INIT Generic Alert for Session Establishment” on page 77.</ul></li><br>
                    <li><ul>Sends a SET_CLOCK protocol command, if supported. </ul></li><br>
                 <li><ul>Sends one or more Display Abnormal Status or Display Status generic<br>
                    commands to retrieve the current status of all the resources. If Display Abnormal<br>
                    Status is not supported, GMFHS issues a Display Status generic command, if<br>
                    supported, for every resource. Whether these commands are supported is<br>
                    specified by the DomainCharacteristics field of the Non_SNA_Domain_Class<br>
                    object that defines the domain to GMFHS.</p></ul></li><br>
                
            <h3><b>Session Establishment for DOMS010 Using CNMS4406</b></h3>
            <p>Some service points that implement the DOMS010 session protocol might not<br>
                provide alerts that are adequate for determining whether the service point is<br>
                running. The CNMS4406 sample is provided by the NetView program to facilitate<br>
                session establishment between GMFHS and these service points.<br>
                This sample provides the INIT and DOWN alert portion of DOMS010 session<br>
                establishment. Use this sample to specify the following items: <br><br>
                <li><ul>The three named elements of a non-SNA domain: the service point (SP), the<br>
                transaction program (TP), and the element management subsystem (EMS). For<br>
                more information about these, see “Defining Non-SNA Domains” on page 34.</ul></li> 
                <li><ul>Whether to send an INIT or DOWN alert. This alert then matches a similarly<br>
                named domain object in RODM with the service point.</ul></li><br>
                The CNMS4406 sample has the following syntax:</p>
                <img src="C:\Users\Shona\Pictures\Screenshots\imagee.png"><br>
                <p>Where:
                    <i>sp_name</i>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates the service point (SP) name as defined to VTAM.</p><br>
                    <br><br><br>
                    <hr><hr>
                    <br><br>
                    <i>tp_name</i>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the transaction program (TP) name.
                </p><br>
                    <i>domain_name</i>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the domain name (also known as the EMS).</p><br>
                    <br>
                    <p>The CNMS4406 sample is a NetView command processor coded in the C language.<br>
                        To use this sample, it must first be compiled using C with the LONGNAME<br>
                        compile option and placed in an executable NetView library. <br>
                        Note: For information about how to compile samples, see <i>IBM Tivoli NetView for<br>
                        z/OS Programming: PL/I and C.</i> For information about the LONGNAME compile<br>
                        option, see the <i>z/OS XL C/C++ Programming Guide (SC09-4765).</i><br>
                        You must also place the following CMDDEF statements in the CNMCMD member<br>
                        in the DSIPARM data set (use included file CNMCMDU for migration purposes):<br>
                        <i>CMDDEF.CNMS4406.MOD=CNMS4406<br>
                        CMDDEF.CNMS4406.RES=N</i><br>
                        For example, to run sample CNMS4406 for a domain object named<br>
                        A0488P31.A94306F8.NETVIEW, an INIT alert can be sent using the following<br>
                        command from either the NetView command facility or the NetView automation<br>
                        table:<br><br>
                    <i>CNMS4406 INIT A0488P31 A94306F8 NETVIEW</i><br>
                        To establish a session between GMFHS and the service point when both are active,<br>
                        place this sample in your automation table to always send the appropriate INIT<br>
                        and DOWN alerts.</p><br><br>
<h4><b>GMFHS-Initiated Session Establishment</b></h4>
<p>Although GMFHS is a passive session partner, it can prompt the element manager<br>
    to initiate a session. The DomainCharacteristics field of a Non_SNA_Domain_Class<br>
    object confirms that a GMFHS session has been established and solicits status from<br>
    the NMG for the domain. This prompting can occur:<br>
    <li><ul>At GMFHS startup, and at user-defined time intervals until the session is<br>
    acquired</ul></li>
    <li><ul>When GMFHS detects an NMG status change to satisfactory, and GMFHS does<br>
    not have a session with an element manager under the NMG</ul></li><br>
    The DOMS010 protocol uses the same protocol commands shown in Table 8 on<br>
    page 66 for the DOMP010 protocol. The exchange occurs as illustrated in Figure 19<br>
    on page 77.</p><br>
    <br><br>
    <hr><hr>
    <br><br>
    <img src="C:\Users\Shona\Pictures\Screenshots\figure19.png"><br><br>
    <p>GMFHS initiates a session with an element manager by sending a<br>
        SESSION_REQUEST protocol command. When the element manager receives this<br>
        command, it responds with SESSION_REQUEST_ACCEPT protocol command and<br>
        generates the generic INIT alert. The rest of this process is described in “Session<br>
        Establishment for DOMS010” on page 74.</p><br><br>
<h3><b>INIT Generic Alert for Session Establishment</b></h3>
<p>In addition to protocol commands, the DOMS010 protocol includes the INIT alert.<br>
    An element manager generates an INIT alert to establish a session with GMFHS.<br><br>
    Table 10 lists the subvectors and data that need to appear in the INIT generic alert.<br>
    <b>Note:</b> Unless noted as optional, all subvectors and data are required.<br><br>
    <i>Table 10. Generic Alert Subvectors</i>
    </p><br>
    <table border="1"cellpadding="1"cellspacing="1">
        <tr><td><b>Subvector</b></td><td><b>Description</b></td></tr>
         <tr><td>Generic alert data subvector</td><td>Alert Type: X'12' (unknown)<br>
            Alert description code: X'FE00' (undetermined error)<br>
            </td></tr>
         <tr><td>Probable cause subvector</td><td>Probable cause code point: X'1001' (application program)</td></tr>
         <tr><td>Cause undetermined<br>
            subvector</td><td>Recommended action code point: X'0700' (no action<br>
                necessary)</td></tr>
         <tr><td>First product set ID subvector</td><td>Product classification: X'xC' (non-IBM software)<br><br>
            Software product common name: Identifier of the NMG<br>
            application (in the non-SNA network) that communicates across the NMG API.<br><br>
            Software product common level: 000000<br><br>
            Software product program number: USER0<br><br>
            <b>Note:</b> The first product set ID subvector is included to<br>
            comply with SNA but does not carry significant<br>
            information.<br>
            </td></tr>
    </table><br><br>
    <hr><hr>
    <br><br>

    <table border="1"cellpadding="1"cellspacing="1">
        <tr><td><b>Subvector
            </b></td><td><b>Description</b></td></tr>

            <tr><td>Second product set ID<br>
                subvector</td><td>Product classification: X'xC' (non-IBM software)<br><br>
                Software product common name: name of the native<br>
                element manager that receives commands<br><br>
                Software product common level: 000000<br><br>
                Software product program number: USER0<br><br>
                Note: The second product set ID subvector is included to<br>
                comply with SNA but does not carry significant<br>
                information.</td></tr>
            <tr><td>Date/Time subvector<br>
                (optional)</td><td>An X'01' subvector containing date and time information.</td></tr>
            <tr><td>Hierarchy resource list<br>
                subvector</td><td>First resource name (mandatory): Name of the service point<br>
                    First resource type identifier (mandatory): X'81' (service<br>
                    point)<br><br>
                    Transaction program resource (optional):<br>
                    Transaction program identifier (optional): X'18' (transaction<br>
                    program)<br>
                    Additional resource name (optional): As required, to<br>
                    uniquely identify the domain<br>
                    Additional resource type identifier (optional): Any<br>
                    Note: The concatenation of resource names, beginning with<br>
                    the service point, with a period (.) as a delimiter between<br>
                    names, needs to be identical to the MyName field of an<br>
                    object in the RODM Non_SNA_Domain_Class object.</td></tr>
            <tr><td>Self-defining text message<br>
                subvector</td><td>Text message: INIT[,GMT=chhmm]<br><br>
                    The optional GMT keyword parameter describes the offset<br>
                    to Greenwich mean time (GMT) for all alerts and command<br>
                    responses that contain status information. The keyword<br>
                    value is formatted as follows: c is the GMT time modifier code: +, -, or Z. <br><br>
                    <li><ul> Specify + to add the GMT modifier to the local time. <br></ul></li>
                        <li><ul>Specify - to subtract the GMT modifier from the local<br>
                    time. </ul></li>
                    <li><ul>Specify Z if the local time is already GMT. In this case<br>
                    hhmm is 0000.<br></ul></li><br>
                    hhmm is the GMT modifier in hours and minutes: <br><br>
                    <li><ul>For hh, the valid range in 24-hour format is 00—23 .</ul></li> <br>
                    <li><ul>For mm The valid minute range is, 00—59.<br></td></tr></ul></li>
    </table><br><br>
<h3><b>Session Termination</b></h3>
Figure 20 on page 79 shows the alert exchange during session termination.<br><br><br>
<hr><hr>
<br><br>
<img src="C:\Users\Shona\Pictures\Screenshots\Figure20.png"><br>
<p><b>Note:</b> The session termination alert is identical to the alert described in “INIT<br>
    Generic Alert for Session Establishment” on page 77, except that the self-defining<br>
    text message subvector contains the text DOWN.<br>
    After GMFHS receives this alert, it considers the session down, and sends no<br>
    commands to the NMG until the session is re-established.<br>
    GMFHS also ends the session if it detects a down state for one of the following<br>
    reasons:<br>
     <li><ul>The status of an NMG changes to Unsatisfactory. <br></ul></li>
     <li><ul>An alert reports a status change of the element manager to Unsatisfactory.<br></ul></li>
     <li><ul>GMFHS receives an INIT alert from the element manager. </ul></li>
     <br>
        If an INIT alert is received,
       the session is ended and immediately re-established.</p><br>
       <hr style="height: 1px; color: black; background-color: black;">
           <h3 class="A"><b>Defining Non-SNA Transport Protocols</b></h3><br>
           <p>The transport protocol definitions control how network control commands are<br>
            transported to their non-SNA resource destinations. Depending on the transport<br>
            protocol you define, you can issue commands at the workstation to control<br>
            non-SNA resources.<br><br>
            The transport protocol field specifies how GMFHS communicates with the network<br>
            management gateway (NMG) when delivering commands and accepting responses<br>
            to commands. The valid protocol names are: <br><br>
            <li><ul>COS indicates that the NMG is a service point and that GMFHS use RUNCMD<br>
            commands to communicate with the service point. </ul></li><br><br>
            <li><ul>PPI indicates that the NMG uses a program-to-program interface (PPI) and that<br>
            GMFHS use the PPI to communicate with a system or network management<br>
            transaction program running in another address space on the focal point host<br>
            communicating with the NetView management console. </ul></li><br><br>
            <li><ul>OST specifies that the NMG is the NetView program and that commands are<br>
            delivered to a NetView OST. v NONE specifies that this NMG does not accept commands.<br>
            Note: If the NMG represents a service point, its name must be the SNA name of<br>
            the service point. If the NMG uses the PPI, its name must be the PPI receiver ID<br>
            used by the NMG. If the NMG is an OST, its name can be any 1-to 8-character<br>
            name.</p></ul></li>
            <br><br><br><br>
            <hr><hr>
            <br><br>
            <h3><b>COS Gateway Support</b></h3>
            <p>The NetView common operations services (COS) gateway support uses the<br>
                RUNCMD command to deliver network control commands to, and receive<br>
                command responses from, service points owned by the central site SSCP or remote<br>
                SSCPs on distributed hosts. Because these service points are accessed by the service<br>
                point command service (SPCS) of the NetView program, GMFHS does not directly<br>
                use the communications network management interface (CNMI) of VTAM for this<br>
                communication.<br><br>
                When you issue a network control command, the transport layer checks the<br>
                network management gateway (NMG) object TransportProtocolName field. If the<br>
                field value is COS, the GMFHS host delivers the command to the GMFHS scope<br>
                checker OPT running in the NetView address space. The scope checker passes the<br>
                command to the GMFHS COS command processor running on a separate autotask.<br><br>
                The COS command processor saves some context information for the command,<br>
                and creates and issues a RUNCMD command containing the command. The<br>
                responses to the RUNCMD command are received by GMFHS COS command<br>
                processor, are correlated to the outstanding command, and are returned to<br>
                GMFHS. The command list issues the RUNCMD command and obtains responses<br>
                for it. When all responses are available, they are returned to the COS command<br>
                processor. The command processor correlates the responses to the command<br>
                context it retained and returns the responses to GMFHS.<br><br>
                If the service point resides in a distributed NetView system, the COS command<br>
                processor routes the command over an LU 6.2 session using the MS transport. The<br>
                NetView program routes the command to the distributed NetView system, runs<br>
                the command on a distributed router autotask, and returns the responses to the<br>
                central site NetView program where they are delivered to the COS command<br>
                processor. The command responses are returned to GMFHS the same way they are<br>
                returned for responses from a local service point.<br><br>
                To use the COS transport protocol, set the value of the TransportProtocolName<br>
                field to COS in the NMG_Class object for that gateway. <br><br>
                If the NetView program is communicating with a service point using LU 6.2 and<br>
                the service point LU has a different NETID than the NetView program that issues<br>
                the RUNCMD, a bit in the NMGCharacteristics field must specify that the SNA<br>
                network name be included in the NETID= keyword parameter of the RUNCMD.<br><br>
                If the NetView program is communicating with a service point using an SSCP-PU<br>
                session and the NetView program that issues the RUNCMD does not own the<br>
                CNMI that communicates with the service point PU, specify the domain name of<br>
                the NetView program that owns the CNMI on the CommandRouteLUName field<br>
                of the NMG_Class object for the service point.<br><br>

                <h3><b>Program-to-Program Interface Gateway</b></h3>

                The program-to-program interface (PPI) for gateway transport allows a process in<br>
                an address space other than a GMFHS or NetView address space to receive generic<br>
                and native network commands from GMFHS, and to return command responses.<br>
                To use the PPI transport type, define an NMG object with a<br>
                TransportProtocolName field value of PPI. The MyName field of this NMG object<br>
                must be the PPI receiver name to which GMFHS is to send commands for this<br>
                gateway.<br><br>
                
                </p>

                <hr><hr>
                <br><br>
                <p>The messages exchanged through the program-to-program interface use the<br>
                    execute run major vector and the reply-to-execute major vector, except as follows: <br>
                    <li><ul> If you specified on the DomainCharacteristics field that command responses are<br>
                    expected from the native element manager, the execute major vector must<br>
                    include a supporting data correlation MS common subvector. The PCID in the<br>
                    supporting data correlation subfield contains the command correlator.</ul></li><br>
                    <li><ul>If GMFHS cannot deliver the execute command, the sense data subvector<br>
                    contains the PPI return code that describes why the PPI send request failed.<br>
                    Refer to the IBM Tivoli NetView for z/OS Application Programmer's Guide for<br>
                    information about PPI return codes.</ul></li></p><br>
                    <h3><b>OST/PPT Gateway</b></h3>
                    The NetView OST/PPT provides a gateway transport facility that allows network<br>
                    control commands to be issued using the NetView operator station task (OST)<br>
                    associated with the workstation originating the command, or using the primary<br>
                    program operator interface (POI) task (PPT), if there is no associated workstation<br>
                    operator. NetView command lists and command processors are initiated in<br>
                    response to commands entered by workstation operators. The following<br>
                    characteristics are in effect for this gateway: <br>
                    <li><ul></ul>Some OST/PPT commands do not produce a command response, even if the<br>
                    expect responses bit of the DomainCharacteristics field is on. </ul></li><br>
                    <li><ul></ul>Command lists or command processors initiated by this gateway can use the<br>
                    NetView GENALERT facility to report current or resulting resource status so<br>
                    that is reflected in the views. If a command initiated by this facility causes a<br>
                    change that otherwise results in an alert being generated for the target resource,<br>
                    the use of the GENALERT is not necessary.</ul></li><br>
                    <h3><b>Monitoring Non-Network Devices</b></h3>
                    The NetView program enables you to monitor non-network devices, such as a line<br>
                    printer. You can write a command list that issues a GENALERT command that<br>
                    generates a generic alert. Define the names of your RODM real resources<br>
                    representing non-network devices and your RODM non-SNA domain objects that<br>
                    report on these devices, so that they follow the naming conventions used by the<br>
                    GENALERT alert resource hierarchy. <br>
                    <h3><b>Types of NMGs</b></h3>
                    GMFHS can communicate with three types of NMGs:<br> 
                    <li><ul>Common operations services NMGs</ul></li>
                        <li><ul>Operator station task NMGs</ul></li>
                            <li><ul>Program-to-program interface NMGs</ul></li>
                    The type of NMG is determined by the TransportProtocol field of the NMG_Class<br>
                    object. All domains managed by an NMG must be of the same type.<br>
                    <h4><b>Common Operations Services NMGs</b></h4>
                    GMFHS communicates with common operations services (COS) NMGs with the<br>
                    NetView RUNCMD command. The network command manager task creates the<br>
                    command text according to the presentation and session protocols, then uses the<br>
                    COS gateway command processor autotask to issue the RUNCMD command and<br>
                    wait for the response. For more information about RUNCMD, see NetView online<br>
                    help.<br>
                    COS NMGs provide the following benefits:<br><br>
                    <hr><hr>
                    <br><br>
                    <li><ul>GMFHS can receive command responses. </ul></li>
                        <li><ul>Depending on the presentation protocol, the command responses can contain<br>
status information that the network command manager task can interpret. </ul></li>
<li><ul>Several current service point applications conform to this architecture. </ul></li>
    <li><ul> The responses to operator-initiated commands are displayed in the Non-SNA<br>
Command Response window. </ul></li><br>

The maximum size of a command to a COS NMG is 240 bytes. If the command<br>
text length for a presentation or session protocol command exceeds 240 bytes after<br>
substitution of any command variables, GMFHS rejects the command.<br><br>

<h3><b>Operator Station Task NMGs</b></h3>

GMFHS communicates with operator station task (OST) NMGs by sending the<br>
command to the requesting operator's OST, or to the PPT for GMFHS-initiated<br>
commands. The network command manager task creates the command text<br>
according to the presentation and session protocols, then uses the host task<br>
manager OPT message queuing service to send the command to the operator's OST<br>
or PPT. GMFHS cannot interpret OST command responses, so all status changes<br>
must be reported to GMFHS as alerts.<br>
The maximum size of a command to an OST NMG is 256 bytes. If the command<br>
text length for a presentation or session protocol command exceeds 256 bytes after<br>
substitution of any command variables, GMFHS rejects the command.<br><br>

<h3><b>Program-to-Program Interface NMGs</b></h3>

GMFHS communicates with program-to-program interface NMGs by exchanging<br>
information with another application registered to the program-to-program<br>
interface. Commands are formatted within an execute command major vector<br>
(X'8061'). Command responses are returned in two response major vectors (X'0061'<br>
and X'1300'). The network command manager task creates the command text<br>
according to the presentation and session protocols, and sends it across the<br>
program- to-program interface to the element manager. The element manager<br>
responds to GMFHS over the program-to-program interface.<br>
Program-to-program interface NMGs provide the following benefits: <br><br>
<li><ul>GMFHS can receive command responses.</ul></li> <br>
<li><ul> Depending on the presentation protocol, the command responses can contain<br>
status information that the network command manager task can interpret.</ul></li> <br>
<li><ul>The responses to operator-initiated commands are displayed in the Non-SNA<br>
Command Response window. The maximum size of a command to a program-to-program interface NMG is 253<br>
bytes. If the command text length for a presentation or session protocol command<br>
exceeds 253 bytes after substitution of any command variables, GMFHS rejects the<br>
command.</ul></li><br>


<h3><b>PPI Command Transport Envelope</b></h3>
<br>
The text of GMFHS commands is transported to the program-to-program interface<br>
NMG in the execute command major vector (X'8061'). This major vector is<br>
described in the System Network Architecture Formats. However, because GMFHS<br>
must have a correlator in command responses, and the architecture of the execute<br>
command major vector does not include a correlator subvector, GMFHS departs<br>
from the architecture by including a subvector that contains a correlator. This<br>
additional correlator is the supporting data correlation subvector (X'48').<br><br><br>
<hr><hr>
<br><br>
<p>Table 11 shows the subvectors and subfields that are included in the execute
    command major vector. <br>
    <i>Table 11. Subvectors and Subfields in the Execute Command Major Vector</i></p>
    <table border="1"cellpadding="1"cellspacing="1">
        <tr><td><b>Subvector</b></td><td>SubField</td><td><b>Description</b></td></tr>
        <tr><td>Name list</td><td>Destination<br>
            application name</td><td>Value of TransactionProgram field in
                Non_SNA_Domain_Class object.</td></tr>
        <tr><td>Self-defining text<br>
            message</td><td>Coded character set<br>
                ID</td><td>X'00000037'</td></tr>
        <tr><td>Self-defining text
            message</td><td>Text Message</td><td> Command text created by the presentation<br>
                layer</td></tr>
        <tr><td>Supporting data<br>
            correlation</td><td>Fully qualified session<br>
                PCID</td><td>PCID: GMFHS internal correlator<br><br>
                    Network-qualified CP name: GMFHS.NETCMD</td></tr>
    </table><br>
    <p>The command response consists of two major vectors: <br>
        <li><ul> Reply to execute command</ul></li>
        <li><ul> Text data parameter</ul></li>
        GMFHS ignores all subvectors in the reply-to-execute-command major vector; no<br>
        subvectors are required. Table 12 shows the subvectors and subfields of the text<br>
        data parameter major vector. <br>
        <i>Table 12. Subvectors and Subfields in the Text Data Parameter Major Vector</i></p>

        <table border="1"cellpadding="1"cellspacing="1">
        <tr><td><b>Subvector</b></td><td>SubField</td><td><b>Description</b></td></tr>
       <tr><td>Supporting data<br>
        correlation</td><td>Fully qualified session<br>
            PCID</td><td>Must be identical to the subvector in the<br>
                command<br>
                PCID: GMFHS internal correlator<br>
                Network-qualified CP name: GMFHS.NETCMD</td></tr>
       <tr><td>Self-defining text<br>
        message</td><td>Text Message</td><td>Command response text</td></tr>
       <tr><td>Self-defining text<br>
        message</td><td>Other Subfields</td><td>GMFHS ignores all other subfields in this<br>
            subvector.</td></tr>
        </table><br><br>
        <hr><hr>
        <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        <hr><hr>
        <br><br>
        <hr style="height: 1px; color: black; background-color: black;"><br><br>

           <h3 class="A"><b>Chapter 5. How GMFHS Uses RODM</b></h3><br>
           <p>The Graphic Monitor Facility host subsystem (GMFHS) works with RODM and a<br>
            NetView management console to display graphic views of networks and issuev
            commands to resources that you select from the view. The views contain both<br>
            status and configuration information about network resources. This chapter<br>
            describes how GMFHS uses RODM. Using this information, you can then modify<br>
            the contents of RODM to change how GMFHS and NetView management console<br>
            perform.</p><br>
            <hr style="height: 1px; color: black; background-color: black;"><br><br>
           <h4><b>GMFHS Initialization</b></h4><br>
           <p>GMFHS can be started with either of two options: <br>
            <li><ul>Aggregation warm start </ul></li>
            <li><ul> Resource status warm start</ul></li>
            The default is that the options are not run and GMFHS is started normally.</p><br>
            <h4><b>Aggregation Warm Start</b></h4><br>
An aggregation warm start is caused by coding the AGGRST=YES parameter in<br>
the GMFHS startup procedure, CNMGMFHS. An object-independent method,<br>
DUIFFAWS, is run to initialize the fields related to status aggregation in the real<br>
and aggregate objects in the RODM data cache. See “DUIFFAWS: Aggregation<br>
Warm Start Method” on page 503 for more information.<br>

<h4><b>Resource Status Warm Start</b></h4>
A resource status warm start is caused by coding the RESWS=YES parameter in<br>
the GMFHS startup procedure, CNMGMFHS.<br>
Resource status warm start provides a mechanism for quickly restoring GMFHS.<br>
Use the resource status warm start option if GMFHS has been abnormally ended,<br>
and the status of the resources in RODM that were managed by GMFHS are still<br>
accurate. GMFHS bypasses the normal resource status initialization process for all<br>
domain resources and uses the existing status information in RODM instead.<br>
GMFHS sets the status of resources on a domain basis. For a resource status warmstart<br>
 to occur, a domain must meet one of the following conditions:<br> 
 <li><ul> Status solicitation of resources was completed successfully the last time GMFHS<br>
was initialized. </ul></li>
<li><ul>Status solicitation is not supported. </ul></li>
    <li><ul> Skip Status solicitation is indicated.</ul></li>
Resource status warm start requires current status data in RODM. To ensure the<br>
current status is maintained in RODM, periodic checkpoints of RODM are required<br>
to save the current domain and resource values. RODM can then be loaded using<br>
the data sets containing the previous checkpoint data.<br>
<b>Notes:</b><br>
1. All status updates are lost for the period between the last checkpoint of RODM<br>
and when GMFHS was reinitialized.<br>
<br><br>
<hr><hr>
<br>
2. If GMFHS and RODM are warm started on a backup host, the DASD that<br>
contains the checkpoint file must be accessible by the backup host.<br>
<h3><b>GMFHS Initialization Process Overview</b></h3>
Normal GMFHS initialization has two subprocesses: <br>
<li><ul>Setup</ul></li><br>
<li><ul>Session Establishment</ul></li><br>
These subprocesses determine the initial status of the resources in each non-SNA<br>
domain. However, under certain circumstances GMFHS does not perform these<br>
steps; this is determined by the values of the following GMFHS start option and<br>
RODM fields:<br>
<li><ul> GMFHS warm start option (resws=yes|no)</ul></li>
<li><ul>The AgentStatus field defined on a NMG_Class object </ul></li>
<li><ul>The AgentStatusEffect field defined on a NMG_Class object </ul></li>
<li><ul>The DomainCharacteristics field defined on a Non_SNA_Class object </ul></li>
<li><ul> The DomainCharacteristics2 field defined on a Non_SNA_Class object</ul></li>
<h3><b>Setup Subprocess</b></h3><br>
Resources under each domain are set to initial, or unknown, status except under<br>
the following conditions: <br>

<li><ul>GMFHS is started with the resource status warm start option (resws=yes) and<br>
the status complete bit is turned on in the DomainCharacteristics2 field. </ul></li>
<li><ul>The skip status setup bit of the DomainCharacteristics field is turned on.</ul></li>
<h3><b>Session Establishment Subprocess</b></h3>
The status of the resources within each domain is solicited if status solicitation is<br>
supported. For more information about status solicitation, see Chapter 4,<br>
“Communicating with Network Management Gateways,” on page 59.<br><br>
GMFHS does not perform the session-establishment subprocess for a domain if<br>
GMFHS is started with the resource status warm-start option (resws=yes), and the<br>
status complete bit of the DomainCharacteristics2 field is turned on. However, if<br>
GMFHS is started with the resource status warm start option (resws=yes), and the<br>
status complete bit of the DomainCharacteristics2 field is turned off, GMFHS<br>
performs the session-establishment subprocess for the domain.<br><br>
If status solicitation is not supported for a domain, resource status is set according<br>
to the following conditions: <br><br>
<li><ul> If the value of the AgentStatusEffect field is X'80' and the status complete bit is<br>
turned on in the DomainCharacteristics2 field, the status of the resources is not<br>
changed. </ul></li><br>
<li><ul> If the value of the AgentStatusEffect field is X'80' and the status complete bit is<br>
turned off in the DomainCharacteristics2 field: </ul></li><br>
– If the value of the AgentStatus field is either 1 or 3, the status of the resources<br>
is set to the status that is indicated by the value of the InitialResourceStatus<br>
field. <br>
– If the value of the AgentStatus field is either 0 or 2, the status of the resources<br>
is set to Unknown. <br>
<li><ul>If the value of the AgentStatusEffect field is X'00', the status of the resources is<br>
set to the status that is indicated by the value of the InitialResourceStatus field.</ul></li><br>
<br><br><br><br>
<hr><hr>
<br>
<hr style="height: 1px; color: black; background-color: black;">

           <h3 class="A"><b>Monitoring Topology Managers</b></h3><br>
<p>GMFHS can monitor the status of topology managers and indicate this status to<br>
    operators. Create one object under the Topology_Manager class to represent each<br>
    topology manager. Note that the SNA topology manager automatically creates this<br>
    object for you.<br>
    Using fields on the Topology_Manager class object, each manager can specify:<br>
     <li><ul>Its status</ul></li><br>
     <li><ul> The interval within which it must indicate its status before GMFHS assumes it is<br>
    unavailable</ul></li><br>
    <li><ul> Its command indicator range</ul></li><br>
    Each manager must periodically update the StatusIndicator field on its object to<br>
    notify GMFHS that it is active. If this field is not updated within the interval<br>
    specified by StatusInterval field, GMFHS reports that the manager is unavailable.<br>
    Topology manager status is displayed in the status area in a NetView management<br>
    console business view, and is summarized on the status bar for open views.</p><br><br>
    <hr style="height: 1px; color: black; background-color: black;">

           <h3 class="A"><b>Building Views</b></h3><br>
           <p>GMFHS builds all views using a 2-step process: <br>
            <li><ul>Object discovery</ul></li>
                <li><ul> Object connectivity</ul></li>
            Object discovery is the process used to determine the list of objects to display in a<br>
            view. This process varies depending on the type of view that is requested.<br>
            Object connectivity is the process used to determine how the objects in the list are<br>
            interconnected in a view. This process is the same for each type of view. See<br>
            “Object Connectivity Process” on page 98 for a description of this process.<br>
            <h3><b>Object Discovery Process</b></h3>
            All of the views that GMFHS builds can be classified in two categories: <br>
            <li><ul>Predefined</ul></li>
            <li><ul>Dynamically built</ul></li>

            <h4><b>Predefined Views</b></h4>
            Predefined views are represented by a view object in RODM. The view object<br>
            contains links to each resource that are in the view. The only object discovery<br>
            processing needed is to query the list of objects currently linked to the view object.<br>
            Note that objects in exception views are not linked.<br>

            <h4><b>Dynamically Built Views</b></h4>
            Dynamically built views are not represented by a view object in RODM.<br>
            Dynamically built views are selected by either choosing an object on an open view<br>
            and issuing an action against it or by issuing a Locate Resource request for a<br>
            specific object. In either case, GMFHS receives the request and determines which<br>
            field on the specified object is queried to find the set of objects necessary to build<br>
            the view. The fields that are queried depend on the type of view.<br> <br>
            For some dynamically built views,GMFHS uses a recursive process to determine<br>
            the complete list of objects that are to be displayed in a view. For example, when a<br>
            configuration parent view is requested for an object, GMFHS determines the parent</p><br>
            <br><br>
            <hr><hr>
            <br>
            <p>of the object. It then determines whether this parent has a parent. This process is<br>
                repeated until a parent object is found that has no parent. See “Restricting<br>
                Recursive Views” on page 111 for more information. The views that use this<br>
                process are identified in “Object Discovery Process Description for Specific Views”<br>
                on page 92.<br>
                The following objects have important roles in the view building process: <br>
                <li><ul>Display_Resource_Type_Class objects</ul></li>
                <li><ul>View_Information_Object_Class objects</ul></li>
                The following overview describes these objects, and “Object Discovery Process<br>
                Description for Specific Views” on page 92 contains a description of how these<br>
                objects are used for each type of view.<br>
                <b>Display_Resource_Type_Class object:</b> A Display_Resource_Type_Class object is<br>
                used to associate an icon with the resource when it is displayed. Displayable<br>
                objects that can be placed in a view must be linked to an object of the<br>
                Display_Resource_Type_Class. Two techniques are available for linking a<br>
                displayable object to the Display_Resource_Type_Class object.<br>
                With the first technique, the DUIFCLRT method is run to link the<br>
                DisplayResourceType field of the displayable object to the Resources field of the<br>
                Display_Resource_Type_Class object as shown in Figure 21. The disadvantage of<br>
                this technique is that you have to run the DUIFCLRT method for each object.</p><br>
                <br>
                <img src="C:\Users\Shona\Pictures\Screenshots\Figure21.png"><br><br>
                <p>With the second technique, you can associate a Display_Resource_Type_Class<br>
                    object with an object class in RODM as shown in Figure 22 on page 89. This is<br>
                    done by creating a View_Information_Reference_Class object, and placing its object<br>
                    ID in the ViewInfoRefObjDRT field on the object class. The DisplayResourceType<br>
                    field of the View_Information_Reference_Class object is then linked to the<br>
                    ResourceClasses field of the Display_Resource_Type_Class object using method<br>
                    DUIFCLRT. The View_Information_Reference_Class object is used, because links<br>
                    cannot be defined at the class level. The ViewInfoRefObjDRT field is inherited by<br>
                    all objects of the class. The advantage to this technique is that the link is defined<br>
                    only once at the class level instead of individually for each object.</p><br>
                <br>
                <hr><hr>
                <br>

                <img src="C:\Users\Shona\Pictures\Screenshots\Figure22.png"><br>
                <p><b>Note:</b> A displayable object can be linked to a Display_Resource_Type_Class object<br>
                    using both techniques. When GMFHS encounters this situation, the first technique,<br>
                    which is shown in Figure 21 on page 88, is used.<br>
                    <b>View_Information_Object_Class object:</b> GMFHS uses<br>
                    View_Information_Object_Class objects for the following purposes: <br>
                    <li><ul>To determine which fields on an object to query to find all other related objects<br>
                    when building some dynamically built views.</ul></li>
                    <li><ul>To determine how objects in a view are connected. See “Object Connectivity<br>
                    Process” on page 98 for more information.</ul></li>
                    For both purposes, however, GMFHS uses a common technique to determine<br>
                    which View_Information_Object_Class object to use. There is one<br>
                    View_Information_Object_Class object for every resource-type and view-type pair<br>
                    that GMFHS defines. All resource types ultimately point to the<br>
                    View_Information_Object_Class objects that represent in which types of views they<br>
                    can be displayed in.<br><br>
                    All view types ultimately point to the View_Information_Object_Class objects that<br>
                    represent the resource types that can be displayed in a particular type of view. For<br>
                    each object-type and view-type pair, there is only one valid<br>
                    View_Information_Object_Class object to represent the combination. The two<br>
                    techniques that can be used to determine the View_Information_Object_Class<br>
                    object, ▌A▐, for a resource are illustrated in Figure 23 on page 90 and in Figure 24<br>
                    on page 91.</p><br>
                    <hr><hr>
                    <br><br>
                    <img src="C:\Users\Shona\Pictures\Screenshots\figure23.png"><br><br><br><br>
                    <hr><hr>
                    <br><br>
                    <img src="C:\Users\Shona\Pictures\Screenshots\figure24.png"><br><br>
                    <p>A displayable object can specify a View_Information_Object_Class object using<br>
                        both the DisplayResourceType field (as shown in Figure 23 on page 90) and the<br>
                        ViewInfoRefObjVIO field (as shown in Figure 24). When GMFHS encounters this<br>
                        situation, it uses the View_Information_Object_Class object pointed to by the<br>
                        ViewInfoRefObjVIO field.<br><br>
                        Either of two scenarios can occur where GMFHS cannot find a valid<br>
                        View_Information_Object_Class object for a displayable object: <br><br>
                        <li><ul>A View_Information_Object_Class object is not found when an operator selects a<br>
                        view type that is not defined for a resource object, called the root object. In this<br>
                        case, GMFHS displays a message stating that the view type is not enabled for<br>
                        this type of object. </ul></li> <br>
                        <li><ul>If an object other than a root object is to be in a view but GMFHS cannot find its<br>
                        View_Information_Object_Class object, GMFHS omits the object and builds the<br>
                        view. Prior to NetView Version 3, if GMFHS cannot find a<br>
                        View_Information_Object_Class object for a resource object, it cannot build the<br>
                        view.</ul></li> </p><br><br>
            <hr><hr>
            <br>
            <h3><b>Object Discovery Process Description for Specific Views</b></h3>
            <p>
                This section describes how GMFHS determines which objects to include in a view. <br>
                Network and exception views are opened by selecting them from the NMC tree<br>
                view. All other types of views are opened by selecting an object rather than a view<br>
                name.<br>
                The following information is provided for each view: <br>
                <li><ul>Whether the view is predefined or dynamically built. Note that some views can<br>
                be either predefined or dynamically built. </ul></li>
                <li><ul>A high level description of the logic that GMFHS uses to discover all of the<br>
                objects. </ul></li>
                <li><ul>The fields that are used by the object discovery process.</ul></li>
            <b>Network Views:</b> Network views are predefined views. Each view is represented<br>
                by a Network_View_Class object in RODM. Every object under this class is queried<br>
                when the NetView management console server establishes a session with GMFHS,<br>
                and is displayed in the NMC tree view. Whenever you add or delete network<br>
                views, this list of views is automatically refreshed. The name of the view that is<br>
                displayed in the list is the value of the MyName field of the Network_View_Class<br>
                object.<br>
                When a network view is opened, the request is passed to GMFHS. GMFHS queries<br>
                the ContainsObjects field of the Network_View_Class object. The list of objects that<br>
                is returned is used by the GMFHS connectivity process. See “Object Connectivity<br>
                Process” on page 98 for a description of this process.<br><br>
            <b>Configuration Peer Views:</b> Configuration peer views are predefined views. Each<br>
                view is represented by a Configuration_Peer_View_Class object in RODM.<br>
                Configuration peer views are similar to network views, but there are two<br>
                significant differences: <br><br>
                <li><ul>Configuration views are not available in the NMC tree view. </ul></li>
                <li><ul> A configuration view is called by object, not by name.</ul></li>
                When a configuration peer view is opened, the request is passed to GMFHS.<br>
                GMFHS queries the ContainedInView field on the selected resource object. This<br>
                field points to every predefined view to which this resource is currently defined.<br>
                For each of these view objects, GMFHS determines its view type by finding the<br>
                class on which the object was created. For each Configuration_Peer_View_Class<br>
                object, GMFHS queries the ContainsObjects field on the specified view object to get<br>
                the list of objects that are to be placed in the view. The list of objects that is<br>
                returned is used by the GMFHS connectivity process. See “Object<br> Connectivity<br>
                Process” on page 98 for a description of this process.<br><br>

                <b>NMC Locate Failing Resources Views:</b> NMC locate failing resources views are<br>
                dynamically built views which are requested by selecting an aggregate object in an<br>
                open view and requesting an NMC locate failing resources view. <br>
                When an NMC locate failing resources view is opened, NetView management<br>
                console passes the request to GMFHS. GMFHS queries the AggregationChild field<br>
                of the selected aggregate object to get a list of all aggregate children objects and<br>
                real children objects of the aggregate object. For each aggregate child object,<br>
                GMFHS queries the AggregationChild field of that object to get its children objects.<br>
                This process is repeated until GMFHS has the complete list of all real objects under<br>
                the original aggregate.</p><br><br>
                <hr><hr>
                <br>
                <p>GMFHS removes all aggregate objects from the list and real objects that meet any<br>
                    of the following criteria: <br>
                    <li><ul>Does not map to an exception state (ResourceTraits contains NOXCPT). </ul></li>
                    <li><ul>Has a UserStatus that indicates the object is suspended from aggregation<br>
                    (UserStatus bit 0x40 is on). </ul></li>
                    <li><ul>Has an AggregationPriorityValue that indicates aggregation is not in use<br>
                    (AggregationPriorityValue = -1).</ul></li>
                    A list of objects that do not meet any of these criteria is passed to the GMFHS<br>
                    connectivity process. See “Object Connectivity Process” on page 98 for a<br>
                    description of this process.<br>
                    <i>Customizing Fast Path to Failing Resource Views:</i> You can determine which objects<br>
                    appear in an NMC locate failing resources view by customizing how the<br>
                    DisplayStatus of an object maps to the exception state of an object. See “Defining<br>
                    Exception View Objects and Criteria” on page 98 for more information about<br>
                    mapping display status to exception state.<br>
                    <b>Configuration Children Views:</b> The configuration children view is a dynamically<br>
                    built view which is requested by selecting an object in an open view and selecting<br>
                    a configuration children view. This view shows the operator all children defined to<br>
                    the selected object. To find the children objects of the selected object, GMFHS uses<br>
                    the following process: <br>
                    <li><ul>Find the View_Information_Object_Class object. </ul></li>
                        <li><ul> Query the RelFieldNamesA field of the View_Information_Object_Class object.<br>
                    For the base GMFHS data model, this field specifies the ChildAccess field. Note<br>
                    that the RelFieldNamesA field is user modifiable and can contain other values. <br>
                    <li><ul>The ChildAccess field contains a pointer to all objects that are children of the<br>
                    object.</ul></li>
                    This process is repeated for each child object of the selected object until the<br>
                    complete list of children is identified. The list of objects is passed to the GMFHS<br>
                    connectivity process. See “Object Connectivity Process” on page 98 for a<br>
                    description of this process.<br>
                    <b>Configuration Parent Views:</b> The configuration parent view is a dynamically<br>
                    built view which is requested by selecting an object from an open view and<br>
                    selecting a configuration parent view. This view shows the selected object,<br>
                    connection to intermediate parents, and connection to the ultimate parent of the<br>
                    selected object. To find the parent objects of the selected object, GMFHS uses the<br>
                    following process: <br>
                    <li><ul>Find the View_Information_Object_Class object. </ul></li>
                        <li><ul>Query the RelFieldNamesA field of the View_Information_Object_Class object.<br>
                    For the base GMFHS data model, this field specifies the ParentAccess field. Note<br>
                    that the RelFieldNamesA field is user modifiable, and can contain other values. </ul></li>
                    <li><ul> The ParentAccess field contains a pointer to all objects that are parent objects of<br>
                    the selected object.</ul></li> <br><br>
                    This process is repeated for each parent object of the selected object until the<br>
                    complete list of parent objects is identified. The list of objects is passed to the<br>
                    GMFHS connectivity process. See “Object Connectivity Process” on page 98 for a<br>
                    description of this process.</p><br><br>
                    <hr><hr>
                    <br><br>
                    <p><b>Configuration Logical Views:</b> The configuration logical view is requested by<br>
                        selecting an object in an open view and then selecting a configuration logical view.<br>
                         This view shows the selected object and all resource objects that are logically<br>
                        connected to it. Configuration logical views can be dynamically built or<br>
                        predefined.<br><br>
                        For dynamically built configuration logical views, GMFHS uses the following<br>
                        process to find the objects that are logically connected to the selected object: <br><br>
                        <li><ul> Find the View_Information_Object_Class object. </ul></li>
                        <li><ul>Query the following fields for the base GMFHS data model: </ul></li>
                        – RelFieldNamesA, which specifies the LogicalConnUpstream field<br>
                        – RelFieldNamesB, which specifies the LogicalConnDownstream field<br>
                        – RelFieldNamesAB, which specifies the LogicalConnPP field.<br>
                        Note that the RelFieldNamesA, RelFieldNamesB, and RelFieldNamesAB fields<br>
                        are user modifiable and can contain other values. <br><br>
                        <li><ul>These fields contain pointers to the objects that are logically connected to the<br>
                        selected object.</ul></li>
                        This process is repeated for each resource object that is logically connected to the<br>
                        selected object until the complete list of objects is identified.<br>
                        For predefined configuration logical views, the request is passed to GMFHS.<br>
                        GMFHS queries the ContainedInView field on the selected resource object. This<br>
                        field points to every predefined view to which this resource is currently defined.<br>
                        For each of these view objects, GMFHS determines its view type by finding the<br>
                        class on which the object was created. For each Configuration_Logical_View_Class<br>
                        object, GMFHS queries the ContainsObjects field on the specified view object to get<br>
                        the list of objects that are to be placed in the view. <br>
                        For both dynamically built and predefined configuration logical views, the list of<br>
                        objects is passed to the GMFHS connectivity process. See “Object Connectivity<br>
                        Process” on page 98 for a description of this process.<br><br>
                        <b>Configuration Physical Views:</b> The configuration physical view is requested by<br>
                        selecting an object from an open view and then selecting a configuration physical<br>
                        view. This view shows the selected object, and all resource objects that are<br>
                        physically connected to it. Configuration physical views can be dynamically built<br>
                        or predefined.<br><br>
                        For dynamically built configuration physical views, GMFHS uses the following<br>
                        process to find the objects that are physically connected to the selected object: <br>
                        <li><ul>Find the View_Information_Object_Class object. </ul></li>
                        <li><ul>Query the following fields for the base GMFHS data model: </ul></li>
                        – RelFieldNamesA, which specifies the PhysicalConnUpstream field<br>
                        – RelFieldNamesB, which specifies the PhysicalConnDownstream field<br>
                        – RelFieldNamesAB, which specifies the PhysicalConnPP field<br>
                        Note that the RelFieldNamesA, RelFieldNamesB, and RelFieldNamesAB fields<br>
                        are user modifiable and can contain other values. <br><br>
                        <li><ul> These fields contain pointers to the objects that are physically connected to the<br>
                        selected object.</ul></li>
                        This process is repeated for each resource object that is physically connected to the<br>
                        selected object until the complete list of objects is identified.</p><br><br>
                        <hr><hr>
                        <br><br>
                        <p>For predefined configuration physical views, the request is passed to GMFHS.<br>
                            GMFHS queries the ContainedInView field on the selected resource object. This<br>
                            field points to every predefined view to which this resource is currently defined.<br><br>
                            For each of these view objects, GMFHS determines its view type by finding the<br>
                            class on which the object was created. For each Configuration_Physical_View_Class<br>
                            object, GMFHS queries the ContainsObjects field on the specified view object to get<br>
                            the list of objects that are to be placed in the view.<br><br>
                             For both dynamically built and predefined configuration physical views, the list of<br>
                            objects is passed to the GMFHS connectivity process. See “Object Connectivity<br>
                            Process” on page 98 for a description of this process.<br><br>
                            <b>Configuration Backbone Views:</b> configuration backbone view is requested by<br>
                            selecting an object from an open view and selecting a configuration backbone view.<br>
                             This view shows the subarea backbone. Configuration backbone views can be<br>
                            dynamically built or predefined.<br><br>
                            For dynamically built configuration backbone views, GMFHS uses the following<br>
                            process to find the backbone objects that are related to the selected object:<br> 
                            <li><ul>  Find the View_Information_Object_Class object.</ul></li>
                                <li><ul>  Query the RelFieldNamesA field of the View_Information_Object_Class object.<br>
                            For the base GMFHS data model, this field specifies the BackboneConnPP field.<br>
                            Note that the RelFieldNamesA field is user modifiable and can contain other<br>
                            values. </ul></li>
                            <li><ul>The BackboneConnPP field contains a pointer to all objects that are part of the<br>
                            SNA backbone.</ul></li>
                            This process is repeated for each backbone object that is related to the selected<br>
                            object until the complete list of backbone objects is identified.<br>
                            For predefined configuration backbone views, the request is passed to GMFHS.<br>
                            GMFHS queries the ContainedInView field on the selected resource object. This<br>
                            field points to every predefined view to which this resource is currently defined.<br>
                            For each of these view objects, GMFHS determines its view type by finding the<br>
                            class on which the object was created. For each<br>
                            Configuration_Backbone_View_Class object, GMFHS queries the ContainsObjects<br>
                            field on the specified view object to get the list of objects that are to be placed in<br>
                            the view. For both dynamically built and predefined configuration backbone views, the list<br>
                            of objects is passed to the GMFHS connectivity process. See “Object Connectivity<br>
                            Process” on page 98 for a description of this process.<br>
                            <b>More Detail Views:</b> More detail views display the next lower layer of child<br>
                            resources for the selected object. There are four types of more detail views: <br>
                            <li><ul>  More detail logical </ul></li>
                                <li><ul>  More detail physical</ul></li> 
                                    <li><ul>  Configuration child II</ul></li>
                                        <li><ul>  Configuration child III</ul></li>
                            One or more of these views can be displayed for the selected resource depending<br>
                            on its resource type.</p><br><br>
                            <hr><hr>
                            <br>
                            <p>
                                If any of these views yield a view with no objects, the view is not returned to the<br>
workstation. If no views can be built, a message is displayed at the workstation<br>
saying the view cannot be found.<br>
The following topics describe how GMFHS builds the four types of more detail<br>
views.<br><br>
<i>More Detail Logical:</i> A more detail logical view can be dynamically built or<br>
predefined. When a more detail logical view is opened, the request is passed to<br>
GMFHS. To determine which objects are in the view, GMFHS performs the<br>
following actions: <br>
<li><ul> Query the ContainsLogical field of the selected object to find the name of the<br>
field that is queried to get the list of objects. For the base GMFHS data model,<br>
this field specifies the ComposedOfLogical field. The ComposedOfLogical field<br>
contains the list of objects that make up the next lower layer of the selected<br>
object. </ul></li>
<li><ul>Pass the list of objects to the GMFHS connectivity process. See “Object<br>
Connectivity Process” on page 98 for a description of this process.<br><br>
<i>More Detail Physical:</i> A more detail physical view can be dynamically built or<br>
predefined. When a more detail physical view is opened, the request is passed to<br>
GMFHS. To determine which objects are in the view, GMFHS performs the<br>
following actions:</ul></li>
<li><ul> Query the ContainsPhysical field of the selected object to find the name of the<br>
field that is queried to get the list of objects. For the base GMFHS data model,<br>
this field specifies the ComposedOfPhysical field. The ComposedOfPhysical field<br>
contains the list of objects that make up the next lower layer of the selected<br>
object.</ul></li>
Pass the list of objects to the GMFHS connectivity process. See “Object<br>
Connectivity Process” on page 98 for a description of this process.<br>
<i>Configuration Child II View:</i> A configuration child II view is a dynamically built<br>
view, which shows a subset of the children defined to the selected logical unit<br>
object. To find the subset of children of the selected object, GMFHS uses the<br>
following process: <br>
<li><ul> Find the View_Information_Object_Class object.</ul></li>
    <li><ul> Query the RelFieldNamesA field of the View_Information_Object_Class object.<br>
This field specifies the list of fields to query to determine the list of the<br>
first-level children.</ul></li>
This process is repeated for each child object of the selected object until the<br>
complete list of children objects is identified. The list of objects is passed to the<br>
GMFHS connectivity process. See “Object Connectivity Process” on page 98 for a<br>
description of this process.<br><br>
If one or more of the fields specified by the RelFieldNamesA field is present on the<br>
selected object, the view is displayed even if there are no children. In this case,<br>
only the selected object is displayed. This view is displayed with a radial layout<br>
with the selected object as the root node.<br>
The following SNA topology manager resource classes use this view type to<br>
display the LU-type objects attached to the selected object: <br></p>
<li><ul> appnEN</ul></li>
    <li><ul> appnNN</ul></li>

    <hr><hr>
    <br>
    <li><ul>crossDomainResource</ul></li>
    <li><ul> interchangeNode</ul></li>
    <li><ul>logicalLink</ul></li>
    <li><ul>logicalUnit </ul></li>
    <li><ul>luGroup</ul></li>
    <li><ul> migrationDataHost</ul></li>
    <li><ul>snaNode</ul></li>
    <li><ul> t5Node</ul></li><br>
<i>Configuration Child III View:</i> A configuration child III view is a dynamically built<br>
view, which shows a subset of the children defined to the selected definition group<br>
object. To find the subset of children of the selected object, GMFHS uses the<br>
following process: <br><br>
<li><ul>Find the View_Information_Object_Class object.</ul></li> <br>
<li><ul> Query the RelFieldNamesA field of the View_Information_Object_Class object.<br>
This field specifies the list of fields to query to determine the list of the<br>
first-level children.</ul></li><br>
This process is repeated for each child object of the selected object until the<br>
complete list of children objects is identified. The list of objects is passed to the<br>
GMFHS connectivity process. See “Object Connectivity Process” on page 98 for a<br>
description of this process.<br>
If one or more of the fields specified by the RelFieldNamesA field is present on the<br>
selected object, the view is displayed even if there are no children. In this case,<br>
only the selected object is displayed. This view is displayed with a hierarchical<br>
layout with the selected object as the root node.<br>
The following SNA topology manager resource classes use this view type to<br>
display the definition group objects attached to the selected object: <br><br>
<li><ul>t5Node</ul></li>
<li><ul> interchangeNode</ul></li>
<li><ul> migrationDataHost </ul></li>
<li><ul>appnEN</ul></li>
<li><ul> appnNN</ul></li>
<li><ul> definitionGroup</ul></li><br>
<b>Exception Views:</b> Exception views are predefined views. Each view is represented<br>
by an object created on the Exception_View_Class in RODM. Every object in this<br>
class is queried when the NetView management console graphic data server or<br>
NetView management console server establishes a session with GMFHS, and is<br>
displayed in the NMC tree view. When you add or delete an exception view, this<br>
list of views is automatically refreshed. The view name displayed is the value of<br>
the MyName field of the Exception_View_Class object.<br><br>
The object discovery process for exception views is different from other predefined<br>
views because the view object does not contain links to each resource in the view.<br> 
For exception views, object discovery is accomplished by defining a list of<br>
candidate objects that can be in an exception view and a series of filters that is<br>
constantly applied to that list. These filters reduce the list to include only those<br>
objects that you want to be displayed in the exception view. For example, you can<br>
<br><br>
<hr><hr>
<br>
<p>define all of your NCPs to an exception view, and set it up so that the only ones<br>
    displayed in the view are the ones having problems that need attention.<br>
    When an exception view is opened, the request is passed to GMFHS, which<br>
    determines the list of candidate objects. The list of candidate objects is found by<br>
    first querying the ExceptionViewName field of the Exception_View_Class object.<br>
    Then GMFHS issues a locate request for the value of that field against the<br>
    ExceptionViewList field in RODM. All objects that are defined as candidates are<br>
    returned with this locate request.<br><br>
    The ExceptionViewFilter field of the Exception_View_Class object contains the<br>
    filters used to reduce this list. For example, using these filters you can filter out<br>
    objects that are currently suspended or marked, or objects whose status is not<br>
    considered a problem. This yields a list of resources that are in a problem state.<br>
    The list of objects, even if empty, is then passed to the NetView management<br>
    console to be displayed.<br><br>
    GMFHS keeps all open exception views current. This is done by determining<br>
    whether views specified in the ExceptionViewList of the resource are open. After<br>
    comparing the filter for each view to the resource, GMFHS determines if the<br>
    resource is either added to, or deleted from, an open exception view. </p><br>
    <h3><b>Object Connectivity Process</b></h3>
    <p>After the object determination process has determined the list of objects that are in<br>
        a view, the list is passed to the object connectivity process. GMFHS must now<br>
        determine how the objects that are listed are interconnected in the view. GMFHS<br>
        does this by performing the following process, sequentially, for each object listed.<br>
        For each object, GMFHS performs the following actions: <br><br>
        <li><ul>Find the View_Information_Object_Class object. </ul></li>
        <li><ul> Query the RelFieldNamesx field. This field specifies which fields are queried on<br>
        the object. </ul></li>
        <li><ul>Query those fields on the object.</ul></li> 
        <li><ul>Compares the object list returned by the query request to the initial object list<br>
        that was passed to the connectivity process. All objects that are contained in<br>
        both lists are connected. </ul></li>
        <li><ul>Pass the view to the NetView management console.</ul></li>
        <b>Notes:</b>
        1. For exception views, GMFHS does not use this process. All objects are<br>
        displayed in a grid, and there is no connectivity relationship among these<br>
        objects.<br>
        2. If GMFHS determines that a node is connected to another node, it inserts a null<br>
        connector link between the two nodes.<br>
        3. If a link does not have real nodes as end points, GMFHS inserts null connector<br>
        nodes.<br>
        </p><br>
        <h4><b>Defining Exception View Objects and Criteria</b></h4>
        <p> To define an exception view complete the following tasks:<br><br>
            1. Create an exception view object and define the criteria for what is considered<br>
            an exception. This step provides the filters that are applied to the exception<br>
            view candidate list, which ultimately defines the object to be displayed in a<br>
            view. </p><br><br>
    <hr><hr>
    <br><br>
    <p>2. Define the objects in RODM that are candidates for exception views.<br>
        All exception views are defined on the NetView host; you cannot customize these<br>
        views from the NetView management console.<br><br>
        Sample DUIFDEXV, Define Exception Views, provides examples for creating four<br>
        exception view objects and setting two ExceptionViewList values for both the<br>
        GMFHS_Managed_Real_Objects_Class and the GMFHS_Aggregate_Objects_Class.<br>
        The prologue of sample DUIFDEXV contains information about how to define an<br>
        exception view for GMFHS objects.<br><br>
        <h4><b>Defining Exception Criteria</b></h4>
        You can define what constitutes an exception for any given exception view and<br>
        resource, thus determining when an object is placed in an exception view. The<br>
        following fields are used to determine when a resource is displayed in an<br>
        exception view: v The value of the UserStatus field of the object<br> 
        <li><ul>The value of the DisplayStatus field of the object</ul></li> <br>
        <li><ul> The value of the ResourceTraits field of the object</ul></li> <br>
        <li><ul> The ExceptionViewFilter field of the Exception_View_Class object</ul></li><br><br>
        The UserStatus field of an object can be used to specify whether an object is<br>
        displayed in an exception view based on an operator entry or an automation<br>
        program. For example, operators can mark the objects on which they are working,<br>
        and you can choose to exclude the marked objects from exception views. Or, if<br>
        your automation routine is trying to recover a failed resource, the automation<br>
        routine can set the automation-in-progress bit of the object, and you can choose to<br>
        exclude these objects from exception views. Use the ExceptionViewFilter to<br>
        customize the processing of these UserStatus values for each exception view.<br><br> 
        The DisplayStatus field of an object contains the basic status information used to<br>
        decide whether an object is placed in an exception view. For example, if the<br>
        DisplayStatus value is 129 (satisfactory), you probably do not want to display the<br>
        object in an exception view. If the DisplayStatus value changes to 130<br>
        (unsatisfactory), you probably do want to display the object. However, you might<br>
        want to display some objects with a DisplayStatus value of 132 (unknown) but not<br>
        display others.<br><br>
        The NetView program supplies a sample table, DUIFSMT, that maps the<br>
        DisplayStatus of objects and classes to exceptions or non-exceptions. This mapping<br>
        is referred to as the exception state of an object.<br><br>
        </p>
        <hr><hr><br>
        <img src="C:\Users\Shona\Pictures\Screenshots\figure25.png"><br><br>
        <p>You can customize how the DisplayStatus is interpreted by modifying the<br>
            DUIFSMT table. See “Customizing the DisplayStatus Mapping Table for Exception<br>
            Views” on page 102 for more information.<br><br>
            You can also create a RODM user method, so that you can access RODM data and<br>
            override the table. See “Creating a DisplayStatus Method for Exception Views” on<br>
            page 109 for more information.<br><br>
            Note: The exception state of an object is one of the criteria used to determine<br>
            which real objects are included in an NMC Locate Failing Resources view. Only<br>
            real objects that map to an exception state are included in an NMC Locate Failing<br>
            Resources view. See “NMC Locate Failing Resources Views” on page 92 for more<br>
            information.<br><br>
            The ResourceTraits field of an object contains the value of how DisplayStatus has<br>
            been interpreted and the state of all UserStatus bits. The ResourceTraits field of an<br>
            object is used when an exception view is built to determine when an object meets<br>
            the criteria for inclusion in an exception view. <br><br>
            The ExceptionViewFilter field of an object is defined on all objects of the<br>
            Exception_View_Class. This field defines the state an object must be in to be<br>
            displayed in an exception view. The value of the ExceptionViewFilter field is<br><br>
            compared to the values for the DisplayStatus and UserStatus fields of the resource<br>
            object as reflected in the ResourceTraits field. If the values of the<br>
            ExceptionViewFilter field and ResourceTraits field match, the object is considered<br>
            an exception and is placed in the defined exception view. See “Defining the<br>
            ExceptionViewFilter Field” on page 101 for a complete description of<br>
            ExceptionViewFilter customization.<br><br>
            </p>
    </body>   
</html>


